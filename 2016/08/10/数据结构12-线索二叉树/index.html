<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>数据结构12.线索二叉树 | Aemonair</title><meta name="description" content="数据结构12.线索二叉树"><meta name="keywords" content="DataStruct,Tree"><meta name="author" content="Air,v.aemonair@gmail.com"><meta name="copyright" content="Air"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="http://ta.qq.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构12.线索二叉树"><meta name="twitter:description" content="数据结构12.线索二叉树"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><meta property="og:type" content="article"><meta property="og:title" content="数据结构12.线索二叉树"><meta property="og:url" content="http://aemonair.github.io/2016/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="og:site_name" content="Aemonair"><meta property="og:description" content="数据结构12.线索二叉树"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://aemonair.github.io/2016/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"><link rel="prev" title="数据结构13.二叉搜索树_BST" href="http://aemonair.github.io/2016/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8413-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/"><link rel="next" title="数据结构11.二叉树" href="http://aemonair.github.io/2016/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8411-%E4%BA%8C%E5%8F%89%E6%A0%91/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?05af6f3318bdeb655af3eaa698a89a71";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-160152781-1', 'auto');
ga('send', 'pageview');
</script><script src="http://tajs.qq.com/stats?sId=66528155" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Aemonair</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#引言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 引言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一．-线索化二叉树"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 一． 线索化二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二．访问线索二叉树"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 二．访问线索二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三．线索二叉树的接口"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 三．线索二叉树的接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五-函数功能检测"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">  五. 函数功能检测</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六-总结"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">  六. 总结</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text"> 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一．-线索化二叉树"><span class="toc-number">2.</span> <span class="toc-text"> 一． 线索化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二．访问线索二叉树"><span class="toc-number">3.</span> <span class="toc-text"> 二．访问线索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三．线索二叉树的接口"><span class="toc-number">4.</span> <span class="toc-text"> 三．线索二叉树的接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-函数功能检测"><span class="toc-number">5.</span> <span class="toc-text">  五. 函数功能检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-总结"><span class="toc-number">6.</span> <span class="toc-text">  六. 总结</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png)"><div id="post-info"><div id="post-title"><div class="posttitle">数据结构12.线索二叉树</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2016-08-10<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-06</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Study/">Study</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="引言"><a href="#引言" class="headerlink" title=" 引言"></a> 引言</h2><p>　　我们知道，二叉树遍历的实质是对非线性结构的树进行线性化的过程，它使得每个节点(除了第一个和最后一个节点外)在这种线性序列中有且仅有一个直接前驱和一个直接后继．但是在二叉链表的存储方式中，我们只能找到每个节点的左右孩子信息，而不能直接得到一个节点在先序，中序和后序遍历这一序列中的前驱和后继信息，这些信息只有在遍历二叉树的动态过程中才能获得．为了保留节点在某种遍历序列中其直接前驱和直接后继的位置信息，可以在每个节点中增加两个指针域来存放在遍历时所得到的有关前驱和后继的信息，但这种方法却降低了存储空间的利用率．<br>　　对于采用二叉链表存储结构的二叉树来说，如果该二叉树有n个节点，则存放这n个节点的二叉链表中就有2n个指针域，且只有n-1个指针域用来存储孩子节点地址的，而另外n+1个指针域为空．因此，可以利用节点空的左指针域(lchild)来指向该节点在某种遍历序列中的直接前驱节点；利用节点空的右指针域(rchild)来指向该节点在某种遍历序列中的直接后继节点．对于那些非空的指针域，则仍然存放指向该节点左右孩子的指针．这些指向直接前驱节点或直接后继节点的指针被称为线索(Thread)，加了线索的二叉树被称为　线索二叉树．<br>　　为二叉树中所有节点排列成一个线性序列可采用不同的遍历方法(即先序，中序，后序)得到．因此,线索二叉树将先序线索二叉树,中序线索二叉树和后序线索二叉树三种.并且,我们把二叉树改造成线索二叉树的过程成为线索化.<br>　　　　<a href="http://img.blog.csdn.net/20160807103945271" target="_blank" rel="noopener" data-fancybox="group" data-caption="线索二叉树.1" class="fancybox"><img alt="线索二叉树.1" title="线索二叉树.1" data-src="http://img.blog.csdn.net/20160807103945271" class="lazyload"></a><br>　　　　对下图中(a)所示二叉树进行线索化,得到的先序线索二叉树,中序线索二叉树,后序线索二叉树分别如图(b)(c)(d)所示,图中的实线表示指针,虚线表示线索.<br>　　　　<a href="http://img.blog.csdn.net/20160807104016006" target="_blank" rel="noopener" data-fancybox="group" data-caption="二叉树及线索后的三种线索二叉树" class="fancybox"><img alt="二叉树及线索后的三种线索二叉树" title="二叉树及线索后的三种线索二叉树" data-src="http://img.blog.csdn.net/20160807104016006" class="lazyload"></a><br>　　　　接下来的问题是:在二叉链表存储中如何区分一个节点的指针域存放的是指针还是线索?这种区分可以用下面两种方法实现.<br>　　　　(1).为每个节点增加两个标志位,<code>left_flag</code>和<code>right_flag</code>,并另:<br>　　　　<br>　　　　left_flag   = { $^{0\ \ \  left_child 指向节点的左孩子}<br>                   _{1\ \ \  left_child 指向节点的右孩子}$</p>
<p>　　　　right_flag = { $^{0\ \ \  right_child 指向节点的左孩子}<br>                   _{1\ \ \  right_child 指向节点的右孩子}$<br>　　　　<br>　　　　每个标志位只占一个bit,这样就只需增加很少的存储空间,这种情况下的节点结构为:</p>
<p>| left_flag | left_child | data | right_child | right_flag |<br>|: —– :|: —– :|: —– :|: —– :|: —– :|: – :|</p>
<p>　　　　(2). 不改变节点的结构,仅在作为线索的地址前加一个负号.也即,负地址表示线索而正地址表示指针. </p>
<p>在此,我们按照第一种方法来介绍线索二叉树的存储.为了将二叉树中所有的空指针都利用起来以及操作方便的需要,在存储线索二叉树时通常增加一个头节点,其结构与其他线索二叉树的节点结构完全一样,只是其存储域不存储数据而已.这个头节点的左指针指向二叉树的根节点,而右指针则指向某种遍历序列的最后一个节点.并且,二叉树在某种遍历下的第一个节点的前驱节点和最后一个节点的后继节点都指向这个头节点.</p>
<hr>
<h2 id="一．-线索化二叉树"><a href="#一．-线索化二叉树" class="headerlink" title=" 一． 线索化二叉树"></a> 一． 线索化二叉树</h2><p>为了实现线索化二叉树,我们将二叉树节点的类型定义修改为:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Tree_node</span><br><span class="line">{</span><br><span class="line">    char data;                     //节点数据</span><br><span class="line">    int left_flag;                 //线索标记</span><br><span class="line">    int right_flag;</span><br><span class="line">    struct *Tree_node *left_child; //左孩子或直接前驱线索指针</span><br><span class="line">    struct *Tree_node *right_child;//右孩子或直接后继线索指针</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>将二叉树线索化的过程,实际上是在二叉树遍历过程中用线索取代空指针的过程.对同一颗二叉树遍历的方式不同,所得到的线索树也不同.但无论哪种遍历,实现线索的方法是一样的,即都是设置一个指针pre始终指向刚被访问过的节点,而指针p则用来指向正在访问的节点,由此记录下遍历过程中访问节点的先后顺序,并对当前访问的节点*p做如下处理:</p>
<ol>
<li>若p所指节点有空指针域,则置相应标记位为1.</li>
<li>若pre != NULL,则看pre所指节点的右标志是否为1,若为1则<code>pre->right_child</code>指向p所指向的当前节点(即节点*pre的直接后继).</li>
<li>若p所指当前节点的左标志为1,则<code>p->left_child</code>指向<code>pre</code>所指向的节点(即节点<code>*pre</code>是节点<code>*p</code>的直接前驱).</li>
<li>将指针pre指向刚访问过的当前节点<code>*p</code>(即<code>pre = p</code>;),而p则下移指向新的当前节点.<br>需要注意的是,在给一棵二叉树添加线索时先要创建一个头节点,并建立头节点与二叉树根节点的线索.当二叉树线索化之后,还需建立最后一个节点与头节点之间的线索.</li>
</ol>
<p>下面,我们将建立中序线索二叉树的算法为例予以说明,该算法分为<code>Thread(p)</code>算法和<code>Creat_Thread(p)</code>算法两部分.</p>
<p>Thread(p)算法用于对<code>*p</code>为根节点的二叉树进行中序线索化.在该算法中,p总指向当前被线索化的节点,而pre作为全局变量则指向刚访问过的节点.也即,<code>*pre</code>是<code>*p</code>的前驱节点,而<code>*p</code>是<code>*pre</code>的后继节点.Thread(p)算法类似中序遍历的递归算法,在p指针不线索化为指向其前驱节点<code>*pre</code>并将其标志位<code>left_flag</code>置为1;否则<code>left_child</code>指向左孩子节点.若<code>*pre</code>节点的<code>right_child</code>指针为<code>NULL</code>,则将<code>right_child</code>指针线索化为指向其后继节点<code>*p</code>并将其标志位<code>right_child</code>置为1;否则<code>right_child</code>指向其右孩子节点.然后将<code>pre</code>指向<code>*p</code>节点,再对<code>*p</code>节点的右子树进行线索化.</p>
<p>Create_Thread(b)算法是对以二叉树存储的二叉树b进行中序线索化,并返回线索化后的头节点指针<code>root</code>.实现方法是:先创建头节点<code>*root</code>,其<code>right_child</code>域为线索,<code>left_child</code>域为链指针并指向二叉树根节点<code>*b</code>.如果二叉树b为空,则将<code>left_child</code>指向头节点自身;否则将<code>*root</code>的<code>left_child</code>指向<code>*b</code>节点,并将pre也指向<code>*root</code>节点.然后调用Thread(b)对整个二叉树线索化,即将指针b传给形参p,从而使得<code>*pre</code>是<code>*p</code>的前驱节点.最后,加入指向头节点的线索,并将头节点的<code>right_child</code>指针域线索化为指向最后一个节点(由于线索化过程是进行到p等于<code>NULL</code>为止,所以最后一个节点就是<code>*pre</code>).</p>
<p>中序线索二叉树算法如下:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">TBTree *pre;                          <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread</span><span class="params">(TBTree *p)</span>                <span class="comment">//对二叉树进行中序线索化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        Thread(p->left_child);        <span class="comment">//先对*p的左子树线索化</span></span><br><span class="line">        <span class="comment">//到此,*p节点的左子树不存在或已线索化,接下来对*p线索化</span></span><br><span class="line">        <span class="keyword">if</span>(p->left_child == <span class="literal">NULL</span>)     <span class="comment">//*p的左孩子不存在则进行前驱线索</span></span><br><span class="line">        {</span><br><span class="line">            p->left_child = pre;      <span class="comment">//建立当前节点*p的前驱线索</span></span><br><span class="line">            p->left_flag = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            p->left_flag = <span class="number">0</span>;          <span class="comment">//置*p的left_child指针为指向左孩子标志</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pre->right_child == <span class="literal">NULL</span>)   <span class="comment">//*pre的右孩子不存在则进行后继线索</span></span><br><span class="line">        {</span><br><span class="line">            pre->right_child = p;      <span class="comment">//建立节点*pre的后继线索</span></span><br><span class="line">            pre->right_flag = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            pre->right_flag = <span class="number">0</span>;        <span class="comment">//置*p的right_child指针为指向右孩子标志</span></span><br><span class="line">        }</span><br><span class="line">        pre = p;                       <span class="comment">//pre移至*p节点</span></span><br><span class="line">        Thread(p->right_child);        <span class="comment">//对*p的右子树线索化</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TBTree *<span class="title">Create_Thread</span><span class="params">(TBTree *b)</span>            <span class="comment">//建立中序线索二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TBTree *root;</span><br><span class="line">    root = (TBTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TBTree));<span class="comment">//创建头节点</span></span><br><span class="line">    root->left_flag = <span class="number">0</span>;</span><br><span class="line">    root->right->flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="literal">NULL</span>)                           <span class="comment">//二叉树为空</span></span><br><span class="line">    {</span><br><span class="line">        root->left_child = root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        root->left_child = b;               <span class="comment">//root是left_child指针指向二叉树根节点*b</span></span><br><span class="line">        pre = root;                         <span class="comment">//*pre是*p的前驱节点,pre指针用于线索</span></span><br><span class="line">        Thread(b);                          <span class="comment">//对二叉树b进行中序线索化</span></span><br><span class="line">        pre->right_child = root;            <span class="comment">//最后处理,加入指向头节点的线索</span></span><br><span class="line">        pre->right_flag = <span class="number">1</span>;</span><br><span class="line">        root->right_child = pre;            <span class="comment">//头节点的right_child指针线索化为指向最后一个节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;                             <span class="comment">//返回线索化后指向二叉树的头节点的指针</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="二．访问线索二叉树"><a href="#二．访问线索二叉树" class="headerlink" title=" 二．访问线索二叉树"></a> 二．访问线索二叉树</h2><p>线索二叉树建立之后,就可以通过线索访问某个节点的前驱节点或后继节点了.但是,由于这种线索是通过二叉树存储结构中的空指针实现的.因此这种线索只是不完整的部分线索,即并不是每个节点的前驱和后继都有指针指向.所以,在访问某个节点的前驱或后继节点时也要分有线索和无线索两种情况来考虑.</p>
<ol>
<li>在中序线索二叉树上查找任意节点的中序前驱节点<br> 对中序线索二叉树上的任一节点<code>*p</code>,寻找其中序前驱节点可分为下面两种情况:<br> (1). 若<code>p->left_flag</code>等于1,则<code>p->left_child</code>即指向前驱节点(<code>p->left_child</code>为线索指针).<br> (2). 若<code>p->left_flag</code>等于0,则表明<code>*p</code>有左孩子.根据中序遍历的定义,<code>*p</code>的前驱节点是以<code>*p</code>的左孩子为根节点的子树的最右节点.也即,沿<code>*p</code>左子树的右指针链向下查找,直到某个节点的右标志<code>right_flag</code>为1时,则该节点就是所找的前驱节点.<br> 在中序线索树上查找<code>*p</code>的中序前驱节点算法如下:<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TBTree *<span class="title">Inpre</span><span class="params">(TBTree *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TBTree *pre;</span><br><span class="line">    pre = p ->left_child;</span><br><span class="line">    <span class="keyword">if</span>(p->left_flag == <span class="number">0</span>)            <span class="comment">//*p有左孩子时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(pre->right_flag == <span class="number">0</span>)  <span class="comment">//沿*p左子树的右指针链向下查找直到某节点的right_flag为1</span></span><br><span class="line">        {</span><br><span class="line">            pre = pre->right_child;  <span class="comment">//返回指向*p的中序前驱节点的指针值</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

</li>
</ol>
<p>2.在中序线索二叉树上查找任意节点的中需后续节点<br>  对于中序线索二叉树上的任一节点<code>*p</code>,寻找其中序后继节点可分为下面两种情况:<br>    (1). 若<code>p->right_flag</code>等于1,则<code>p->right_child</code>即指向后继节点.<br>    (2). 若<code>p->left_flag</code>等于0,则表明<code>*p</code>有右孩子.根据中序遍历的定义,<code>*p</code>的后继节点是以<code>*p</code>的右孩子为根节点的子树的最左节点.也即,沿<code>*p</code>右子树的左指针链向下查找,直到某个节点的左标志<code>left_flag</code>为1时,则该节点就是所找的后继节点.<br>    在中序线索树上查找<code>*p</code>的中序后继节点算法如下:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TBTree *<span class="title">InPost</span><span class="params">(TBTree *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TBTree *post;</span><br><span class="line">    post = p ->right_child;</span><br><span class="line">    <span class="keyword">if</span>(p->right_flag == <span class="number">0</span>)           <span class="comment">//*p有右孩子时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(post->left_flag == <span class="number">0</span>)  <span class="comment">//沿*p右子树的左指针链向下查找直到某节点的left_flag为1</span></span><br><span class="line">        {</span><br><span class="line">            pre = pre->left_child;   <span class="comment">//返回指向*p的中序后继节点的指针值</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">}	</span><br><span class="line">```	</span><br><span class="line"><span class="number">3.</span>中序遍历中序线索二叉树</span><br><span class="line">   在中序线索二叉树中,开始节点就是根节点的最左下节点,而求当前节点在中序序列中的后继和前驱节点方法如前所述,并且最后一个节点的`right_child`指针被线索化为指向头节点.利用这些条件,在中序线索二叉树中实现中序遍历的算法如下:</span><br><span class="line">```c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(TBTree *b)</span>             <span class="comment">//中序遍历中序线索二叉树</span></span></span><br><span class="line"><span class="function"></span>{                                   <span class="comment">//*b为中序线索二叉树的头节点</span></span><br><span class="line">    TBTree *p;</span><br><span class="line">    p = b->left_child;              <span class="comment">//p指向根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != b)                   <span class="comment">//当p不等于指向头节点的指针b时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(p->left_flag == <span class="number">0</span>)   <span class="comment">//寻找中序序列中的第一个节点</span></span><br><span class="line">        {</span><br><span class="line">            p = p ->left_child;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3c"</span>, p->data);    <span class="comment">//输出中序序列的第一个节点数据</span></span><br><span class="line">        <span class="keyword">while</span>(p->right_flag == <span class="number">1</span> && p->right_child != b)</span><br><span class="line">        {                          <span class="comment">//后续线索存在且后续线索不为头节点时</span></span><br><span class="line">            p = p->right_child;    <span class="comment">//根据后继线索找到后继节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c"</span>, p->data);<span class="comment">//输出后继节点信息</span></span><br><span class="line">        }</span><br><span class="line">        p = p->right_child;        <span class="comment">//无后继线索则p指向右孩子节点</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="三．线索二叉树的接口"><a href="#三．线索二叉树的接口" class="headerlink" title=" 三．线索二叉树的接口"></a> 三．线索二叉树的接口</h2><ul>
<li><p><code>thread_tree.h</code></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _THREAD_TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _THREAD_TREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tools.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ONE    ( 1 )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD ( 1 )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK   ( 0 )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END    (<span class="meta-string">'#'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree_node</span> <span class="title">Tree_node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree_node</span>{</span></span><br><span class="line">    <span class="keyword">char</span>              data;                                                 <span class="comment">//数据区域</span></span><br><span class="line">    <span class="keyword">int</span>          left_flag;</span><br><span class="line">    <span class="keyword">int</span>         right_flag;</span><br><span class="line">    Tree_node * left_child;    </span><br><span class="line">    Tree_node *right_child;</span><br><span class="line">};                 </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Tree_node *Bin_tree;                                                <span class="comment">//二叉树的根节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Tree_node *<span class="title">find_parent</span><span class="params">(Bin_tree root, Tree_node *node)</span></span>;</span><br><span class="line"><span class="function">Tree_node *<span class="title">get_parent</span><span class="params">(Bin_tree root, Tree_node *kid)</span></span>;</span><br><span class="line"><span class="comment">//二叉树的接口</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_tree</span><span class="params">(<span class="keyword">char</span> **str)</span></span>;                                           <span class="comment">//一.1.创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_print</span><span class="params">(Bin_tree root)</span></span>;                                        <span class="comment">//三.1.前序递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_order_print</span><span class="params">(Bin_tree root)</span></span>;                                        <span class="comment">//三.2.中序递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_print</span><span class="params">(Bin_tree root)</span></span>;                                       <span class="comment">//三.3.后序递归遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一.先序线索二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一.1 先序线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_thread</span><span class="params">(Bin_tree tree)</span></span>;</span><br><span class="line"><span class="comment">//一.2 创建先序线索二叉树</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_pre_thread</span><span class="params">(Bin_tree tree)</span></span>;</span><br><span class="line"><span class="comment">//一.3 先序线索二叉树中节点的前驱</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">front_in_pre</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span>;</span><br><span class="line"><span class="comment">//一.4 先序线索二叉树中节点的后继</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">behind_in_pre</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span>;</span><br><span class="line"><span class="comment">//一.5 遍历输出先序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_print_thread</span><span class="params">(Bin_tree root)</span></span>;</span><br><span class="line"><span class="comment">//一.6 销毁先序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_pre</span><span class="params">(Bin_tree root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二.中序线索二叉树</span></span><br><span class="line"><span class="comment">//二.1 中序线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_thread</span><span class="params">(Bin_tree tree)</span></span>;</span><br><span class="line"><span class="comment">//二.2 创建中序线索二叉树</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_mid_thread</span><span class="params">(Bin_tree tree)</span></span>;</span><br><span class="line"><span class="comment">//二.3 中序线索二叉树中节点的前驱</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">front_in_mid</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span>;</span><br><span class="line"><span class="comment">//二.4 中序线索二叉树中节点的后继</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">behind_in_mid</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span>;</span><br><span class="line"><span class="comment">//二.5 遍历输出中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_order_print_thread</span><span class="params">(Bin_tree root)</span></span>;         </span><br><span class="line"><span class="comment">//二.6 销毁中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_mid</span><span class="params">(Bin_tree root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三.后序线索二叉树</span></span><br><span class="line"><span class="comment">//三.1 后序线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_thread</span><span class="params">(Bin_tree tree)</span></span>;</span><br><span class="line"><span class="comment">//三.2 创建后序线索二叉树</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_last_thread</span><span class="params">(Bin_tree tree)</span></span>;</span><br><span class="line"><span class="comment">//三.3 后序线索二叉树中节点的前驱</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">front_in_last</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span>;</span><br><span class="line"><span class="comment">//三.4 后序线索二叉树中节点的后继</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">behind_in_last</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span>;</span><br><span class="line"><span class="comment">//三.5 遍历输出后序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_print_thread</span><span class="params">(Bin_tree root)</span></span>;</span><br><span class="line"><span class="comment">//三.6 销毁后序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_last</span><span class="params">(Bin_tree root)</span></span>;</span><br><span class="line">                      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_THREAD_TREE_H_</span></span></span><br></pre></td></tr></tbody></table></figure></div>

<p>四. 线索二叉树的接口实现</p>
</li>
<li><p>-</p>
</li>
<li><p><code>thread_tree.c</code></p>
</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdlib.h></stdlib.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><string.h></string.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><strings.h></strings.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><unistd.h></unistd.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><math.h></math.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread_tree.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tools.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"queue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的接口</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Tree_node *<span class="title">create_node</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">char</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Bin_tree root)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Tree_node *<span class="title">find_common</span><span class="params">(Bin_tree root,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Tree_node *node1, Tree_node *node2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> b > a ? b : a;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> Tree_node *<span class="title">create_node</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *node = (Tree_node *)Malloc(<span class="keyword">sizeof</span>(Tree_node));</span><br><span class="line">    bzero(node, <span class="keyword">sizeof</span>(Tree_node));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">char</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// abcdefg</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     e</span></span><br><span class="line">    <span class="keyword">char</span> *local = <span class="built_in">strchr</span>(<span class="built_in">string</span>, value);</span><br><span class="line">    <span class="keyword">return</span> local == <span class="literal">NULL</span> ? <span class="number">-1</span> : (local - <span class="built_in">string</span>) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Tree_node *<span class="title">find_parent</span><span class="params">(Bin_tree root,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Tree_node *kid)</span>    <span class="comment">//找到指定节点的双亲节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *temp = root;</span><br><span class="line">    <span class="keyword">if</span>(temp->left_child == kid)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        temp = temp->left_child;</span><br><span class="line">        <span class="keyword">while</span>(temp->left_child != kid && temp->right_child != kid)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp->left_flag == LINK)</span><br><span class="line">            {</span><br><span class="line">                temp = temp->left_child;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                temp = temp->right_child;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Tree_node *<span class="title">get_parent</span><span class="params">(Bin_tree root, Tree_node *kid)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || kid == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't find.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    Tree_node *temp = root;</span><br><span class="line">    <span class="keyword">if</span>(temp->left_child == kid)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        temp = temp->left_child;</span><br><span class="line">        <span class="keyword">while</span>(temp->left_child != kid && temp->right_child != kid)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(temp->right_flag == LINK)</span><br><span class="line">            {</span><br><span class="line">                temp = temp->right_child;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                temp = temp->left_child;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一.创建二叉树</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_tree</span><span class="params">(<span class="keyword">char</span> **str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Bin_tree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">NULL</span> && *str != <span class="literal">NULL</span> && **str != END){</span><br><span class="line">        root = create_node();  </span><br><span class="line">        root->data = **str;</span><br><span class="line">        root->left_flag = LINK;</span><br><span class="line">        root->right_flag = LINK;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//处理完当前节点，然后递归地创建其左右孩子</span></span><br><span class="line">        <span class="comment">//++*str;</span></span><br><span class="line">        (*str)++;</span><br><span class="line">        root->left_child = create_tree(str);</span><br><span class="line">        <span class="comment">//++*str;</span></span><br><span class="line">        (*str)++;</span><br><span class="line">        root->right_child = create_tree(str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三.1.前序递归遍历</span></span><br><span class="line"><span class="comment">//void pre_order_print(Bin_tree root);                                  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_print</span><span class="params">(Bin_tree root)</span>    <span class="comment">//前序递归遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>){</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%c "</span>, root->data);</span><br><span class="line">         pre_order_print(root->left_child);</span><br><span class="line">         pre_order_print(root->right_child);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//三.2.中序递归遍历</span></span><br><span class="line"><span class="comment">//void mid_order_print(Bin_tree root);                                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_order_print</span><span class="params">(Bin_tree root)</span>    <span class="comment">//中序递归遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>){</span><br><span class="line">         mid_order_print(root->left_child);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%c "</span>, root->data);</span><br><span class="line">         mid_order_print(root->right_child);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//三.3.后序递归遍历</span></span><br><span class="line"><span class="comment">//void last_order_print(Bin_tree root);                                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_print</span><span class="params">(Bin_tree root)</span>    <span class="comment">//后序递归遍历</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>){</span><br><span class="line">         last_order_print(root->left_child);</span><br><span class="line">         last_order_print(root->right_child);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%c "</span>, root->data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Tree_node *pre = <span class="literal">NULL</span>;      <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一.1 先序线索化</span></span><br><span class="line"><span class="comment">//先对根节点进行线索化,再对左右孩子进行线索化.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_thread</span><span class="params">(Bin_tree tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!tree->left_child)</span><br><span class="line">        {</span><br><span class="line">            tree->left_child = pre;</span><br><span class="line">            tree->left_flag = THREAD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            tree->left_flag = LINK;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pre->right_child == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            pre->right_child = tree;</span><br><span class="line">            pre->right_flag = THREAD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            pre->right_flag = LINK;</span><br><span class="line">        }</span><br><span class="line">        pre = tree;</span><br><span class="line">        <span class="keyword">if</span>(tree->left_flag == LINK)</span><br><span class="line">            pre_thread(tree->left_child);</span><br><span class="line">        <span class="keyword">if</span>(tree->right_flag == LINK)</span><br><span class="line">            pre_thread(tree->right_child);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//一.2 创建先序线索二叉树</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_pre_thread</span><span class="params">(Bin_tree tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Bin_tree root = <span class="literal">NULL</span>;</span><br><span class="line">    root = create_node();                      <span class="comment">//创建头节点root</span></span><br><span class="line">    root->left_flag = LINK;</span><br><span class="line">    root->right_flag = THREAD;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>)                           <span class="comment">//二叉树为空</span></span><br><span class="line">    {</span><br><span class="line">        root->left_child = root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pre = root;</span><br><span class="line">        root->left_child = tree;               <span class="comment">//root的左孩子指向tree</span></span><br><span class="line">        pre_thread(tree);                      <span class="comment">//线索化二叉树tree</span></span><br><span class="line">        pre->right_child = root;               <span class="comment">//遍历完后最后一个pre指向root</span></span><br><span class="line">        pre->right_flag = THREAD;</span><br><span class="line">        root->right_child = pre;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在前序线索二叉树中找到节点p_node的前一个节点</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            A</span></span><br><span class="line"><span class="comment">//          /   \</span></span><br><span class="line"><span class="comment">//         B     G</span></span><br><span class="line"><span class="comment">//        / \   /  \</span></span><br><span class="line"><span class="comment">//       C   D H   J </span></span><br><span class="line"><span class="comment">//          / \ \</span></span><br><span class="line"><span class="comment">//         E   F I </span></span><br><span class="line"><span class="comment">//    在前序线索二叉树中,遍历顺序为"根左右",</span></span><br><span class="line"><span class="comment">//    对上面这个二叉树转化为前序线索二叉树之后,前序遍历为 A B C D E F G H I J </span></span><br><span class="line"><span class="comment">//    对节点而言,先根A然后左子树B,B作为根,左子树C,右子树D,D作为根节点,左子树E,右子树F...</span></span><br><span class="line"><span class="comment">//    某一节点的前一个节点,</span></span><br><span class="line"><span class="comment">//    1.作为左子树,前一个节点即是其父节点.</span></span><br><span class="line"><span class="comment">//    2.作为右子树,因为是"根左右"的顺序,于是,其前一个节点为兄弟的最右节点.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//一.3 先序线索二叉树中节点的前驱</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">front_in_pre</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *front = <span class="literal">NULL</span>;</span><br><span class="line">    Tree_node *parent = <span class="literal">NULL</span>;</span><br><span class="line">    front = p_node->left_child;              <span class="comment">//先指向p_node左孩子</span></span><br><span class="line">    <span class="keyword">if</span>(p_node->left_flag == LINK)</span><br><span class="line">    {</span><br><span class="line">        parent = find_parent(root, p_node);  <span class="comment">//查找p_node的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(parent->left_child == p_node)     <span class="comment">//情况1. 作为左节点</span></span><br><span class="line">        {</span><br><span class="line">            front = parent;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>                                 <span class="comment">//情况2.</span></span><br><span class="line">        {</span><br><span class="line">            front = parent->left_child;      <span class="comment">//查找左子树的最右节点</span></span><br><span class="line">            <span class="keyword">while</span>(front->right_flag == LINK)</span><br><span class="line">            {</span><br><span class="line">                front = front->right_child;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在前序线索二叉树中找到节点p_node的后一个节点</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            A</span></span><br><span class="line"><span class="comment">//          /   \</span></span><br><span class="line"><span class="comment">//         B     G</span></span><br><span class="line"><span class="comment">//        / \   /  \</span></span><br><span class="line"><span class="comment">//       C   D H   J </span></span><br><span class="line"><span class="comment">//          / \ \</span></span><br><span class="line"><span class="comment">//         E   F I </span></span><br><span class="line"><span class="comment">//    在前序线索二叉树中,遍历顺序为"根左右",</span></span><br><span class="line"><span class="comment">//    对上面这个二叉树转化为前序线索二叉树之后,前序遍历为 A B C D E F G H I J </span></span><br><span class="line"><span class="comment">//    对节点而言,先根A然后左子树B,B作为根,左子树C,右子树D,D作为根节点,左子树E,右子树F...</span></span><br><span class="line"><span class="comment">//    某一节点的后一个节点,</span></span><br><span class="line"><span class="comment">//    1.如果有左孩子,按照根左右的顺序,找当前节点的左节点.</span></span><br><span class="line"><span class="comment">//    2.如果有后继(left_flag == 1),则其right_child其后继.</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//一.4 先序线索二叉树中节点的后继</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">behind_in_pre</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *behind = <span class="literal">NULL</span>;</span><br><span class="line">    behind = p_node->left_child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_node->left_flag == LINK)          <span class="comment">//p_node有左孩子</span></span><br><span class="line">    {</span><br><span class="line">        behind = p_node->left_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>                                   <span class="comment">//有线索后继</span></span><br><span class="line">    {</span><br><span class="line">        behind = p_node->right_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> behind;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//一.5 遍历输出先序线索二叉树</span></span><br><span class="line"><span class="comment">//根左右的顺序</span></span><br><span class="line"><span class="comment">//先输出根节点,然后找其左孩子,若没有左孩子,根据后继寻找下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_print_thread</span><span class="params">(Bin_tree root)</span></span></span><br><span class="line"><span class="function"></span>{                                           <span class="comment">//root为前序线索二叉树的头节点</span></span><br><span class="line">    Tree_node *p_node = <span class="literal">NULL</span>;</span><br><span class="line">    p_node = root->left_child;              <span class="comment">//p_node指向根节点tree</span></span><br><span class="line">    <span class="keyword">while</span>(p_node != root)                   <span class="comment">//当p_node不等于指向头节点的指针root时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3c"</span>, p_node->data);        <span class="comment">//输出前序序列的一个根节点数据</span></span><br><span class="line">        <span class="keyword">if</span>(p_node->left_flag == LINK)       <span class="comment">//前序序列中根节点的左孩子</span></span><br><span class="line">        {</span><br><span class="line">            p_node = p_node ->left_child;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {                                   </span><br><span class="line">            p_node = p_node->right_child;   <span class="comment">//根据后继线索找到后继节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}   </span><br><span class="line"><span class="comment">//一.6 销毁先序线索二叉树</span></span><br><span class="line"><span class="comment">//与遍历顺序相同,保存当前节点,得到下一个时释放当前资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_pre</span><span class="params">(Bin_tree root)</span>    </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == root)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Tree_node *p_node = root->left_child;</span><br><span class="line">    Tree_node *pre = p_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p_node != root)</span><br><span class="line">    {</span><br><span class="line">        pre = p_node;                          <span class="comment">//保存当前根节点</span></span><br><span class="line">        <span class="keyword">if</span>(p_node->left_flag == LINK)          <span class="comment">//找其左子树</span></span><br><span class="line">        {</span><br><span class="line">            p_node = p_node->left_child;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>                                   <span class="comment">//寻找其后继</span></span><br><span class="line">        {</span><br><span class="line">            p_node = p_node->right_child;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">free</span>(pre);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//二.中序线索二叉树</span></span><br><span class="line"><span class="comment">//二.1 中序线索化</span></span><br><span class="line"><span class="comment">//按"左根右"的顺寻进行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_thread</span><span class="params">(Bin_tree tree)</span>                <span class="comment">//对二叉树进行中序线索化</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        mid_thread(tree->left_child);        <span class="comment">//先对tree的左子树线索化</span></span><br><span class="line">        <span class="comment">//到此,tree节点的左子树不存在或已线索化,接下来对tree线索化</span></span><br><span class="line">        <span class="keyword">if</span>(tree->left_child == <span class="literal">NULL</span>)         <span class="comment">//tree的左孩子不存在则进行前驱线索</span></span><br><span class="line">        {</span><br><span class="line">            tree->left_child = pre;          <span class="comment">//建立当前节点tree的前驱线索</span></span><br><span class="line">            tree->left_flag = THREAD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            tree->left_flag = LINK;          <span class="comment">//置tree的left_child指针为指向左孩子标志</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pre->right_child == <span class="literal">NULL</span>)         <span class="comment">//pre的右孩子不存在则进行后继线索</span></span><br><span class="line">        {</span><br><span class="line">            pre->right_child = tree;         <span class="comment">//建立节点pre的后继线索</span></span><br><span class="line">            pre->right_flag = THREAD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            pre->right_flag = LINK;          <span class="comment">//置p的right_child指针为指向右孩子标志</span></span><br><span class="line">        }</span><br><span class="line">        pre = tree;                          <span class="comment">//pre移至tree节点</span></span><br><span class="line">        mid_thread(tree->right_child);       <span class="comment">//对tree的右子树线索化</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//二.2 创建中序线索二叉树</span></span><br><span class="line"><span class="comment">//创建一个root根节点,对tree进行中序线索化</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_mid_thread</span><span class="params">(Bin_tree tree)</span>  </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Bin_tree root = <span class="literal">NULL</span>;</span><br><span class="line">    root = create_node();                   <span class="comment">//创建头节点</span></span><br><span class="line">    root->left_flag = LINK;</span><br><span class="line">    root->right_flag = THREAD;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>)                        <span class="comment">//二叉树为空</span></span><br><span class="line">    {</span><br><span class="line">        root->left_child = root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        root->left_child = tree;            <span class="comment">//root的left_child指针指向二叉树根节点tree</span></span><br><span class="line">        pre = root;</span><br><span class="line">        mid_thread(tree);                   <span class="comment">//对二叉树tree进行中序线索化</span></span><br><span class="line">        pre->right_child = root;            <span class="comment">//最后处理,加入指向头节点的线索</span></span><br><span class="line">        pre->right_flag = THREAD;</span><br><span class="line">        root->right_child = pre;            <span class="comment">//头节点的right_child指针线索化为指向最后一个节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;                            <span class="comment">//返回线索化后指向二叉树的头节点的指针root</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//在中序线索二叉树中查找某节点的前一个节点</span></span><br><span class="line"><span class="comment">//按"左根右"的顺序而言,</span></span><br><span class="line"><span class="comment">//若p_node的left_flag为1,则p_node的left_child即为其前驱节点</span></span><br><span class="line"><span class="comment">//若p_node的left_flag为0,则p_node有左子树,前驱则在其左子树的最右孩子节点</span></span><br><span class="line"><span class="comment">//                   </span></span><br><span class="line"><span class="comment">//          A        </span></span><br><span class="line"><span class="comment">//        /   \</span></span><br><span class="line"><span class="comment">//       B     G     </span></span><br><span class="line"><span class="comment">//      / \    / \</span></span><br><span class="line"><span class="comment">//     C   D  H   J  </span></span><br><span class="line"><span class="comment">//        / \  \</span></span><br><span class="line"><span class="comment">//       E   F  I        </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 中序: C B E D F A H I G J </span></span><br><span class="line"><span class="comment">//二.3 中序线索二叉树中节点的前驱</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">front_in_mid</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *front = <span class="literal">NULL</span>;</span><br><span class="line">    front = p_node->left_child;</span><br><span class="line">    <span class="keyword">if</span>(p_node->left_flag == LINK)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(front->right_flag == LINK)      <span class="comment">//查找最右孩子</span></span><br><span class="line">        {</span><br><span class="line">            front = front->right_child;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//中序线索二叉树中查找某节点后继节点</span></span><br><span class="line"><span class="comment">//按"左根右"的顺序而言,</span></span><br><span class="line"><span class="comment">//若p_node的right_flag为1,则p_node的right_child即为其后继节点</span></span><br><span class="line"><span class="comment">//若p_node的right_flag为0,则p_node有右子树,前驱则在其右子树的最左孩子节点</span></span><br><span class="line"><span class="comment">//二.4 中序线索二叉树中节点的后继</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">behind_in_mid</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *behind = <span class="literal">NULL</span>;</span><br><span class="line">    behind = p_node->right_child;</span><br><span class="line">    <span class="keyword">if</span>(p_node->right_flag == LINK)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(behind->left_flag == LINK)</span><br><span class="line">        {</span><br><span class="line">            behind = behind->left_child;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> behind;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//中序遍历中序线索二叉树</span></span><br><span class="line"><span class="comment">//          A        </span></span><br><span class="line"><span class="comment">//        /   \</span></span><br><span class="line"><span class="comment">//       B     G     </span></span><br><span class="line"><span class="comment">//      / \    / \</span></span><br><span class="line"><span class="comment">//     C   D  H   J  </span></span><br><span class="line"><span class="comment">//        / \  \</span></span><br><span class="line"><span class="comment">//       E   F  I        </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 中序: C B E D F A H I G J </span></span><br><span class="line"><span class="comment">//二.5 遍历输出中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_order_print_thread</span><span class="params">(Bin_tree root)</span>             </span></span><br><span class="line"><span class="function"></span>{                                      <span class="comment">//root为中序线索二叉树的头节点</span></span><br><span class="line">    Tree_node *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = root->left_child;              <span class="comment">//p指向根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != root)                   <span class="comment">//当p不等于指向头节点的指针root时</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(p->left_flag == LINK)    <span class="comment">//寻找中序序列中的第一个节点</span></span><br><span class="line">        {</span><br><span class="line">            p = p ->left_child;        <span class="comment">//最左孩子</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3c"</span>, p->data);        <span class="comment">//输出中序序列的第一个节点数据</span></span><br><span class="line">        <span class="keyword">while</span>(p->right_flag == THREAD && p->right_child != root)</span><br><span class="line">        {                              <span class="comment">//后续线索存在且后续线索不为头节点时</span></span><br><span class="line">            p = p->right_child;        <span class="comment">//根据后继线索找到后继节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c"</span>, p->data);    <span class="comment">//输出后继节点信息</span></span><br><span class="line">        }</span><br><span class="line">        p = p->right_child;            <span class="comment">//无后继线索则p指向右孩子节点</span></span><br><span class="line">    }</span><br><span class="line">}   </span><br><span class="line"><span class="comment">//二.6 销毁中序线索二叉树</span></span><br><span class="line"><span class="comment">//以遍历的顺序依次销毁释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_mid</span><span class="params">(Bin_tree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *p_node = <span class="literal">NULL</span>;</span><br><span class="line">    Tree_node *pre_node = <span class="literal">NULL</span>;                  <span class="comment">//用pre_node保存上一个节点</span></span><br><span class="line">    p_node = root->left_child;</span><br><span class="line">    <span class="keyword">while</span>(p_node != root)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(p_node->left_flag == LINK)</span><br><span class="line">        {</span><br><span class="line">            p_node = p_node->left_child;         <span class="comment">//最左孩子</span></span><br><span class="line">        }</span><br><span class="line">        pre_node = p_node;                       <span class="comment">//保存当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(p_node->right_flag == THREAD && p_node->right_child != root)</span><br><span class="line">        {</span><br><span class="line">            p_node = p_node->right_child;        <span class="comment">//p_node指向新的后继节点后,释放上一个节点</span></span><br><span class="line">            <span class="built_in">free</span>(pre_node);</span><br><span class="line">            pre_node = p_node;</span><br><span class="line">        }</span><br><span class="line">        p_node = p_node->right_child;</span><br><span class="line">        <span class="built_in">free</span>(pre_node);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//三.后序线索二叉树</span></span><br><span class="line"><span class="comment">//三.1 后序线索化</span></span><br><span class="line"><span class="comment">//按照"左右根"的顺序进行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_thread</span><span class="params">(Bin_tree tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        last_thread(tree->left_child);</span><br><span class="line">        last_thread(tree->right_child);</span><br><span class="line">        <span class="keyword">if</span>(tree->left_child == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            tree->left_child = pre;</span><br><span class="line">            tree->left_flag = THREAD;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(pre->right_child == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            pre->right_child = tree;</span><br><span class="line">            pre->right_flag = THREAD;</span><br><span class="line">        }</span><br><span class="line">        pre = tree;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//三.2 创建后序线索二叉树</span></span><br><span class="line"><span class="comment">//创建新节点root指向原来的tree</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_last_thread</span><span class="params">(Bin_tree tree)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Bin_tree root = <span class="literal">NULL</span>;</span><br><span class="line">    root = create_node();                     <span class="comment">//新节点root</span></span><br><span class="line">    root->right_flag = LINK;</span><br><span class="line">    root->right_child = root;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>)                          <span class="comment">//无二叉树时</span></span><br><span class="line">    {</span><br><span class="line">        root->left_child = root;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pre = root;</span><br><span class="line">        root->left_child = tree;              <span class="comment">//root指向tree</span></span><br><span class="line">        root->left_flag = LINK;</span><br><span class="line">        last_thread(tree);                    <span class="comment">//后序线索化tree</span></span><br><span class="line">        root->right_child = pre;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在后序线索二叉树中寻找某节点的前驱节点</span></span><br><span class="line"><span class="comment">//由于是后序遍历,以"左右根"的顺序遍历,所以,</span></span><br><span class="line"><span class="comment">//某节点若为根,其right_flag为0,即有右孩子则其right_child即为其前驱.</span></span><br><span class="line"><span class="comment">//否则,找其左孩子.</span></span><br><span class="line"><span class="comment">//三.3 后序线索二叉树中节点的前驱</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">front_in_last</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p_node->right_flag == LINK)</span><br><span class="line">    {</span><br><span class="line">        front = p_node->right_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        front = p_node->left_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在后序线索二叉树中寻找某节点的后继节点</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//          A        </span></span><br><span class="line"><span class="comment">//        /   \</span></span><br><span class="line"><span class="comment">//       B     G     </span></span><br><span class="line"><span class="comment">//      / \    / \</span></span><br><span class="line"><span class="comment">//     C   D  H   J  </span></span><br><span class="line"><span class="comment">//        / \  \</span></span><br><span class="line"><span class="comment">//       E   F  I     </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// C E F D B I H J G A </span></span><br><span class="line"><span class="comment">// (左右根)</span></span><br><span class="line"><span class="comment">// 1. 若right_flag == 1, 即为线索,则其right_child即为后继;</span></span><br><span class="line"><span class="comment">// 2. 找到当前节点的父节点,若当前节点为其父节点的右孩子,即此父节点为其后继</span></span><br><span class="line"><span class="comment">// 3. 上图中的B,其后继节点为I,即其兄弟节点左子树里的最深节点</span></span><br><span class="line"><span class="comment">//三.4 后序线索二叉树中节点的后继</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">behind_in_last</span><span class="params">(Bin_tree root, Tree_node *p_node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *behind = <span class="literal">NULL</span>;</span><br><span class="line">    Tree_node *parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p_node->right_flag == THREAD)      <span class="comment">//1. 后继</span></span><br><span class="line">    {</span><br><span class="line">        behind = p_node->right_child;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        parent = find_parent(root, p_node);</span><br><span class="line">        <span class="keyword">if</span>(parent->right_child == p_node)</span><br><span class="line">        {</span><br><span class="line">            behind = parent;              <span class="comment">//2. 父节点为其后继</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>                              <span class="comment">//3. 跨越子树的后继节点</span></span><br><span class="line">        {</span><br><span class="line">            behind = parent->right_child;</span><br><span class="line">            <span class="keyword">while</span>(behind->left_flag == LINK || behind->right_flag == LINK)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(behind->left_flag == LINK)</span><br><span class="line">                {</span><br><span class="line">                    behind = behind->left_child;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    behind = behind->right_child;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> behind;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出后序线索二叉树</span></span><br><span class="line"><span class="comment">//按"左右根"的顺序,自底向上输出</span></span><br><span class="line"><span class="comment">//          A        </span></span><br><span class="line"><span class="comment">//        /   \</span></span><br><span class="line"><span class="comment">//       B     G     </span></span><br><span class="line"><span class="comment">//      / \    / \</span></span><br><span class="line"><span class="comment">//     C   D  H   J  </span></span><br><span class="line"><span class="comment">//        / \  \</span></span><br><span class="line"><span class="comment">//       E   F  I     </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// C E F D B I H J G A </span></span><br><span class="line"><span class="comment">// (左右根)</span></span><br><span class="line"><span class="comment">//                                  取得C,输出C,找到C的父节点B,</span></span><br><span class="line"><span class="comment">// C不是B的右孩子,向下查找,到D,     再到E,输出E,找到E的父节点D,</span></span><br><span class="line"><span class="comment">// E不是D的右孩子,向下查找,         取得F,输出F,找到F的父节点D,</span></span><br><span class="line"><span class="comment">// F为D的右孩子,                    取得D,输出D,找到D的父节点B,</span></span><br><span class="line"><span class="comment">// D为B的右孩子,                    取得B,输出B,找到B的父节点A,</span></span><br><span class="line"><span class="comment">// B不是A的右孩子,向下查找,到G,到H, 取得I,输出I,找到I的父节点H,</span></span><br><span class="line"><span class="comment">// I为H的右孩子,                    取得H,输出H,找到H的父节点G,</span></span><br><span class="line"><span class="comment">// H不是G的右孩子,                  取得J,输出J,找到J的父节点G,</span></span><br><span class="line"><span class="comment">// J为G的右孩子,                    取得G,输出G,找到G的父节点A,</span></span><br><span class="line"><span class="comment">// G为A的右孩子,                    取得A,输出A;  </span></span><br><span class="line"><span class="comment">//三.5 遍历输出后序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_print_thread</span><span class="params">(Bin_tree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *temp = root->left_child;</span><br><span class="line">    Tree_node *parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(temp->left_flag == LINK)</span><br><span class="line">        {</span><br><span class="line">            temp = temp->left_child;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(temp->right_flag == LINK)</span><br><span class="line">        {</span><br><span class="line">            temp = temp->right_child;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;                        <span class="comment">//1.找到左子树中最深的节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(temp != root)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3c"</span>, temp->data);        <span class="comment">//2. 输出节点信息 </span></span><br><span class="line">        parent = get_parent(root, temp);  <span class="comment">//3. 获取父节点</span></span><br><span class="line">        <span class="keyword">if</span>(parent == root)</span><br><span class="line">        {</span><br><span class="line">            temp = root;                  <span class="comment">//完毕</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(parent->right_flag == THREAD || temp == parent->right_child)</span><br><span class="line">        {</span><br><span class="line">            temp = parent;                <span class="comment">//当前节点为父节点的右孩子</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(parent->right_flag == LINK)</span><br><span class="line">            {</span><br><span class="line">                parent = parent->right_child;</span><br><span class="line">                <span class="keyword">while</span>(parent->left_flag == LINK)</span><br><span class="line">                {</span><br><span class="line">                    parent = parent->left_child;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            temp = parent;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//三.6 销毁后序线索二叉树</span></span><br><span class="line"><span class="comment">//通过遍历的顺序,依次保存上一个并销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_last</span><span class="params">(Bin_tree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *temp = root->left_child;</span><br><span class="line">    Tree_node *parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(temp->left_flag == LINK)</span><br><span class="line">        {</span><br><span class="line">            temp = temp->left_child;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(temp->right_flag == LINK)</span><br><span class="line">        {</span><br><span class="line">            temp = temp->right_child;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;                           <span class="comment">//找到最左节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(temp != root)</span><br><span class="line">    {</span><br><span class="line">        parent = get_parent(root, temp);</span><br><span class="line">        <span class="keyword">if</span>(parent == root)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            temp = root;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(parent->right_flag == THREAD || temp == parent->right_child)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            temp = parent;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(parent->right_flag == LINK)</span><br><span class="line">            {</span><br><span class="line">                parent = parent->right_child;</span><br><span class="line">                <span class="keyword">while</span>(parent->left_child == LINK)</span><br><span class="line">                {</span><br><span class="line">                    parent = parent->left_child;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">            temp = parent;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="五-函数功能检测"><a href="#五-函数功能检测" class="headerlink" title="  五. 函数功能检测"></a>  五. 函数功能检测</h2><ul>
<li>main.c</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread_tree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PRINT_TREE_  1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Bin_tree root0 = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root1 = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root2 = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root3 = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root4 = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root5 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//  char *str = "ABC####";</span></span><br><span class="line">    <span class="keyword">char</span> *str0 = <span class="string">"ABC##DE##F##GH#I##J##"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"ABCE###DF##G##HI##J##"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"ABCD###E#F##G#HI##J##"</span>;</span><br><span class="line">    Boolean equal = FALSE;</span><br><span class="line"></span><br><span class="line">    Tree_node *p_node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"一.1.创建二叉树\n"</span>);</span><br><span class="line"></span><br><span class="line">    root0 = create_tree(&str0);    <span class="comment">//二叉树的创建</span></span><br><span class="line">    root1 = create_tree(&str1);    <span class="comment">//二叉树的创建</span></span><br><span class="line">    root2 = create_tree(&str2);    <span class="comment">//二叉树的创建</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _PRINT_TREE_</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     root0:                root1:                 root2:             \n"</span>);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                  A                   A               A              \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                /   \\               /   \\           /   \\         \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               B     G             B     H         B     G           \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"              / \\    / \\          / \\   /         / \\     \\     \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"             C   D  H   J        C   D  I        C   E     H         \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                / \\  \\          /   / \\  \\      /    \\    / \\  \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               E   F  I        E   F   G  J    D      F  I   J       \n"</span>);            </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"二.遍历二叉树：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pre order root0 :\n"</span>);</span><br><span class="line">    pre_order_print(root0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order root1 :\n"</span>);</span><br><span class="line">    mid_order_print(root1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"last order root2 :\n"</span>);</span><br><span class="line">    last_order_print(root2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n遍历前序线索二叉树:\n"</span>);</span><br><span class="line">    root3 = create_pre_thread(root0);</span><br><span class="line"></span><br><span class="line">    pre_order_print_thread(root3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    p_node = root3->left_child->left_child->right_child;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"front is : %c  ,"</span>,front_in_pre(root3, p_node)->data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The node: %c  ,"</span>,p_node->data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"behind is : %c\n"</span>,behind_in_pre(root3, p_node)->data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n遍历中序线索二叉树:\n"</span>);</span><br><span class="line">    root4 = create_mid_thread(root1);</span><br><span class="line"></span><br><span class="line">    mid_order_print_thread(root4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    p_node = root4->left_child->left_child->right_child;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"front is : %c  ,"</span>,front_in_mid(root4, p_node)->data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The node: %c  ,"</span>,p_node->data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"behind is : %c\n"</span>,behind_in_mid(root4, p_node)->data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n遍历后序线索二叉树:\n"</span>);</span><br><span class="line">    root5 = create_last_thread(root2);</span><br><span class="line">    </span><br><span class="line">    last_order_print_thread(root5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    p_node = root5->left_child->left_child->right_child;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"front is : %c  ,"</span>,front_in_last(root5, p_node)->data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The node: %c  ,"</span>,p_node->data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"behind is : %c\n"</span>,behind_in_last(root5, p_node)->data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//destroy_tree(&root);</span></span><br><span class="line">    destroy_pre(root3);</span><br><span class="line">    destroy_mid(root4);</span><br><span class="line">    destroy_last(root5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<ul>
<li>运行结果</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">root@aemonair:~thread_tree<span class="meta"># cc.sh *.c</span></span><br><span class="line">Compiling ...</span><br><span class="line">-e CC      dlist.c main.c <span class="built_in">queue</span>.c <span class="built_in">stack</span>.c thread_tree.c tools.c -g -lpthread -lm</span><br><span class="line">-e         Completed .</span><br><span class="line">-e         Wed Aug <span class="number">10</span> <span class="number">19</span>:<span class="number">01</span>:<span class="number">18</span> CST <span class="number">2016</span></span><br><span class="line">root@aemonair:~thread_tree# ./dlist </span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br><span class="line">一<span class="number">.1</span>.创建二叉树</span><br><span class="line">     root0:                root1:                 root2:             </span><br><span class="line">                  A                   A               A              </span><br><span class="line">                /   \               /   \           /   \         </span><br><span class="line">               B     G             B     H         B     G           </span><br><span class="line">              / \    / \          / \   /         / \     \     </span><br><span class="line">             C   D  H   J        C   D  I        C   E     H         </span><br><span class="line">                / \  \          /   / \  \      /    \    / \  </span><br><span class="line">               E   F  I        E   F   G  J    D      F  I   J       </span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br><span class="line">二.遍历二叉树：</span><br><span class="line">pre order root0 :</span><br><span class="line">A B C D E F G H I J </span><br><span class="line">mid order root1 :</span><br><span class="line">E C B F D G A I H J </span><br><span class="line">last order root2 :</span><br><span class="line">D C F E B I J H G A </span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br><span class="line"></span><br><span class="line">遍历前序线索二叉树:</span><br><span class="line">  A  B  C  D  E  F  G  H  I  J</span><br><span class="line">front is : C  ,The node: D  ,behind is : E</span><br><span class="line"></span><br><span class="line">遍历中序线索二叉树:</span><br><span class="line">  E  C  B  F  D  G  A  I  H  J</span><br><span class="line">front is : F  ,The node: D  ,behind is : G</span><br><span class="line"></span><br><span class="line">遍历后序线索二叉树:</span><br><span class="line">  D  C  F  E  B  I  J  H  G  A</span><br><span class="line">front is : F  ,The node: E  ,behind is : B</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="  六. 总结"></a>  六. 总结</h2><p>   线索二叉树,将二叉树之间用线索相连,将没用到的指针用起来,将各个节点见关系串联起来.<br>    在实现的过程中,某一个节点的顺序和其父节点或者兄弟节点之间的关系由节点之间的指针关系相当密切.<br>    线索二叉树作为一种数据结构,各种操作思想也是很重要的~</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:v.aemonair@gmail.com">Air</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aemonair.github.io/2016/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/">http://aemonair.github.io/2016/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Aemonair.github.io">Aemonair</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStruct/">DataStruct    </a><a class="post-meta__tags" href="/tags/Tree/">Tree    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2016/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8413-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>数据结构13.二叉搜索树_BST</span></div></a></div><div class="next-post pull_right"><a href="/2016/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8411-%E4%BA%8C%E5%8F%89%E6%A0%91/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>数据结构11.二叉树</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2016/07/31/数据结构10-树/" title="数据结构10.树"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-07-31</div><div class="relatedPosts_title">数据结构10.树</div></div></a></div><div class="relatedPosts_item"><a href="/2016/08/26/数据结构14-自平衡二叉查找树-AVL树/" title="数据结构14.自平衡二叉查找树_AVL树"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-08-26</div><div class="relatedPosts_title">数据结构14.自平衡二叉查找树_AVL树</div></div></a></div><div class="relatedPosts_item"><a href="/2016/08/20/数据结构13-二叉搜索树-BST/" title="数据结构13.二叉搜索树_BST"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-08-20</div><div class="relatedPosts_title">数据结构13.二叉搜索树_BST</div></div></a></div><div class="relatedPosts_item"><a href="/2016/08/05/数据结构11-二叉树/" title="数据结构11.二叉树"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-08-05</div><div class="relatedPosts_title">数据结构11.二叉树</div></div></a></div><div class="relatedPosts_item"><a href="/2016/07/24/Sort_2_QuickSort/" title="排序_2.快速排序"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-07-24</div><div class="relatedPosts_title">排序_2.快速排序</div></div></a></div><div class="relatedPosts_item"><a href="/2016/07/28/Sort_4_ShellSort/" title="排序_4.希尔排序"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-07-28</div><div class="relatedPosts_title">排序_4.希尔排序</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Air</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">4th ~</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script></body></html>