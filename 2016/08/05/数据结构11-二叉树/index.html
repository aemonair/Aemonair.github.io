<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>数据结构11.二叉树 | Aemonair</title><meta name="description" content="数据结构11.二叉树"><meta name="keywords" content="DataStruct,Tree"><meta name="author" content="Air,v.aemonair@gmail.com"><meta name="copyright" content="Air"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="http://ta.qq.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构11.二叉树"><meta name="twitter:description" content="数据结构11.二叉树"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><meta property="og:type" content="article"><meta property="og:title" content="数据结构11.二叉树"><meta property="og:url" content="http://aemonair.github.io/2016/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8411-%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="og:site_name" content="Aemonair"><meta property="og:description" content="数据结构11.二叉树"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://aemonair.github.io/2016/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8411-%E4%BA%8C%E5%8F%89%E6%A0%91/"><link rel="prev" title="数据结构12.线索二叉树" href="http://aemonair.github.io/2016/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"><link rel="next" title="数据结构10.树" href="http://aemonair.github.io/2016/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8410-%E6%A0%91/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?05af6f3318bdeb655af3eaa698a89a71";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-160152781-1', 'auto');
ga('send', 'pageview');
</script><script src="http://tajs.qq.com/stats?sId=66528155" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Aemonair</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#引言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">引言</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#II-特点："><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">　II. 特点：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#III-区别："><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">　III. 区别：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#IV-形态："><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">　IV. 形态：　　</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1）-满二叉树"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">　　1）. 满二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2）-完全二叉树"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">　　2）. 完全二叉树</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三．二叉树的存储"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">三．二叉树的存储</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四．二叉树的遍历"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">四．二叉树的遍历</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#I-遍历二叉树的递归算法及遍历示例"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">I. 遍历二叉树的递归算法及遍历示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#II-遍历二叉树的非递归算法"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">II.遍历二叉树的非递归算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#III-二叉树的层次遍历算法"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">*III. 二叉树的层次遍历算法 *</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五．二叉树的操作接口及程序代码"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">五．二叉树的操作接口及程序代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六-二叉树操作接口实现："><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">六.二叉树操作接口实现：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#七．功能检测"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">七．功能检测</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结："><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">总结：</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#II-特点："><span class="toc-number">1.1.</span> <span class="toc-text">　II. 特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III-区别："><span class="toc-number">1.2.</span> <span class="toc-text">　III. 区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IV-形态："><span class="toc-number">1.3.</span> <span class="toc-text">　IV. 形态：　　</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1）-满二叉树"><span class="toc-number">1.3.1.</span> <span class="toc-text">　　1）. 满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2）-完全二叉树"><span class="toc-number">1.3.2.</span> <span class="toc-text">　　2）. 完全二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三．二叉树的存储"><span class="toc-number">2.</span> <span class="toc-text">三．二叉树的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四．二叉树的遍历"><span class="toc-number">3.</span> <span class="toc-text">四．二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-遍历二叉树的递归算法及遍历示例"><span class="toc-number">3.1.</span> <span class="toc-text">I. 遍历二叉树的递归算法及遍历示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-遍历二叉树的非递归算法"><span class="toc-number">3.2.</span> <span class="toc-text">II.遍历二叉树的非递归算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#III-二叉树的层次遍历算法"><span class="toc-number">3.3.</span> <span class="toc-text">*III. 二叉树的层次遍历算法 *</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五．二叉树的操作接口及程序代码"><span class="toc-number">4.</span> <span class="toc-text">五．二叉树的操作接口及程序代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-二叉树操作接口实现："><span class="toc-number">5.</span> <span class="toc-text">六.二叉树操作接口实现：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七．功能检测"><span class="toc-number">6.</span> <span class="toc-text">七．功能检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结："><span class="toc-number">7.</span> <span class="toc-text">总结：</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png)"><div id="post-info"><div id="post-title"><div class="posttitle">数据结构11.二叉树</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2016-08-05<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-06</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Study/">Study</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>　　二叉树是一种非常重要的非线性结构，许多实际问题抽象出来的数据结构往往都是二叉树的形式．与树相比，二叉树更加规范并更具确定性，并且实现二叉树的存储结构及其算法都较为简单，因此二叉树就显得格外重要．  </p>
</blockquote>
<p>　　在计算机科学中，<strong>二叉树</strong>（Binary tree）是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二元堆积。<br>　<br>一．二叉树的定义<br>–<br>###　 I. 定义：<br>　　<strong>二叉树</strong>是n(n>=0)个节点的有限集合，它或者是空树(n=0)，或者是由一个根节点及两颗互不相交，分别称作该根节点的＂左子树＂和＂右子树＂的二叉树构成．
　　</p>
<h3 id="II-特点："><a href="#II-特点：" class="headerlink" title="　II. 特点："></a>　II. 特点：</h3><p>　　二叉树与树的定义一样，都是递归的．<br>　　并且，二叉树具有如下两个<strong>特点</strong>：<br>　　　1. 二叉树不存在度大于２的结点．<br>　　　2. 二叉树每个节点至多有两棵子树且有左，右之分，次序不能颠倒．</p>
<h3 id="III-区别："><a href="#III-区别：" class="headerlink" title="　III. 区别："></a>　III. 区别：</h3><p>　与树的区别：<br>　　<br>　　1. 树的节点个数至少为1，而二叉树的节点个数可以为0；<br>　　2. 树中节点的最大度数没有限制，而二叉树节点的最大度数为2；<br>　　3. 树的节点无左、右之分，而二叉树的节点有左、右之分。(二叉树任何一个节点的子树都要区分左右子数，即使这个节点只有一棵子树时也要明确指出它是左子树还是右子树．)
　</p>
<h3 id="IV-形态："><a href="#IV-形态：" class="headerlink" title="　IV. 形态：　　"></a>　IV. 形态：　　</h3><p>　　根据二叉树的定义，二叉树有如图的五种形态：<br>　　a. 为空二叉树(用Φ表示∅Ø )<br>　　b. 为只有一个根节点而无子树的二叉树<br>　　c. 为只有左子树而无右子树的二叉树<br>　　d. 为只有右子树而无左子树的二叉树<br>　　e. 为左右子树均非空的二叉树<br>　　<a href="http://img.blog.csdn.net/20160731150709892" target="_blank" rel="noopener" data-fancybox="group" data-caption="二叉树的五种基本形态" class="fancybox"><img alt="二叉树的五种基本形态" title="二叉树的五种基本形态" data-src="http://img.blog.csdn.net/20160731150709892" class="lazyload"></a></p>
<p>###　ｖ. 类型</p>
<h4 id="1）-满二叉树"><a href="#1）-满二叉树" class="headerlink" title="　　1）. 满二叉树"></a>　　1）. 满二叉树</h4><p>　　　　　我们将称具有如下性质的二叉树为满二叉树：<br>　　　　　1. 不存在度为1的节点，即所有分支节点都有左子树和右子树．<br>　　　　　2. 所有叶子节点都在同一层上．<br>　　　　　<a href="http://img.blog.csdn.net/20160731155029598" target="_blank" rel="noopener" data-fancybox="group" data-caption="满二叉树" class="fancybox"><img alt="满二叉树" title="满二叉树" data-src="http://img.blog.csdn.net/20160731155029598" class="lazyload"></a><br>　　　　　图a即为满二叉树，图b则不是满二叉树，因为其叶子节点不在同一层上．<br>　　<br>　　　　　一棵深度为k，且有 <code>2^(k-1)</code>个节点的二叉树，称为满二叉树（Full Binary Tree）。这种树的特点是每一层上的节点数都是最大节点数。
　　　　　</p>
<h4 id="2）-完全二叉树"><a href="#2）-完全二叉树" class="headerlink" title="　　2）. 完全二叉树"></a>　　2）. 完全二叉树</h4><p>　　　　　而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。<br>　　　　　<br>　　　　　对一棵具有n个节点的二叉树，将树中的节点按自上而下，从左向右的顺序进行编号，如果编号i(1 ≤ i  ≤ n)的节点与满二叉树中的编号为i的节点在二叉树中的位置相同，则这棵二叉树成为完全二叉树．<br>　　　　<a href="http://img.blog.csdn.net/20160731163929712" target="_blank" rel="noopener" data-fancybox="group" data-caption="完全二叉树与非完全二叉树．例１" class="fancybox"><img alt="完全二叉树与非完全二叉树．例１" title="完全二叉树与非完全二叉树．例１" data-src="http://img.blog.csdn.net/20160731163929712" class="lazyload"></a><br>　　　　<a href="http://img.blog.csdn.net/20160731164028152" target="_blank" rel="noopener" data-fancybox="group" data-caption="完全二叉树与非完全二叉树．例２" class="fancybox"><img alt="完全二叉树与非完全二叉树．例２" title="完全二叉树与非完全二叉树．例２" data-src="http://img.blog.csdn.net/20160731164028152" class="lazyload"></a><br>　　　　<br>二．二叉树的性质<br>–</p>
<blockquote>
<p>(向下取整的运算称为Floor，用数学符号⌊⌋表示，<code>⌊x⌋</code>表示不大于x的最大整数，如<code>⌊3.7⌋=7</code>；<br>与之相对的，向上取整的运算称为Ceiling，用数学符号⌈⌉表示。<code>⌈x⌉</code>表示不小于x的最小整数，<code>⌈3.7⌉=4</code>)  ;</p>
</blockquote>
<ul>
<li><p><strong>性质1.</strong>　<br>　　非空二叉树的第<code>i</code>层上最多有<code>2^(i-1)</code>个节点(i≥1)；</p>
</li>
<li><p><strong>性质2.</strong>　<br>　　深度为<code>k</code>的二叉树最多有 <code>2^k-1</code>个结点(k≥1)，最少有h个结点；</p>
</li>
<li><p><strong>性质3.</strong>　<br>　　对于任意一棵非空二叉树，如果其叶结点(度为0)数为<code>n0</code>，而度数为2的结点总数为<code>n2</code>，则<code>n0=n2+1</code>；</p>
</li>
<li><p><strong>性质4.</strong>　<br>　　具有<code>n</code>个结点的完全二叉树的深度为 <code>⌊log2n⌋+1</code>；</p>
</li>
<li><p><strong>性质5.</strong>　<br>　　有<code>n</code>个结点的完全二叉树各结点如果按层次自上而下且每层从左到右用顺序方式存储，从<code>1</code>到<code>n</code>进行编号，则对任意序号为<code>i</code>的结点有如下关系：<br>　 　1. 如果<code>i>1</code>，则其父结点的编号为<code>⌊i/2⌋</code>；若i=1,则i为根节点序号；<br>　 　2. 如果<code>2i ≤ n</code>，则其左儿子（即左子树的根结点）的编号为<code>2i</code>；否则<code>i</code>无左儿子；<br>　 　3. 如果<code>2i+1 ≤ n</code>，则其右儿子的结点编号为<code>2i+1</code>；否则<code>i</code>无右儿子。</p>
</li>
<li><p><strong>性质6.</strong><br>　　给定<code>n</code>个节点，能构成<code>h(n)</code>种不同的二叉树。<br>　　<code>h(n)</code>为卡特兰数的第<code>n</code>项。<br>　　<code>h(n)=C(2*n，n)/(n+1)</code>。</p>
</li>
<li><p><strong>性质7.</strong>　<br>　　设有<code>i</code>个枝点，<code>i</code>为所有枝点的道路长度总和，<code>j</code>为叶的道路长度总和<code>j=i+2i</code></p>
</li>
</ul>
<h2 id="三．二叉树的存储"><a href="#三．二叉树的存储" class="headerlink" title="三．二叉树的存储"></a>三．二叉树的存储</h2><p> 　　二叉树的存储方法有以下几种。</p>
<ul>
<li><strong>1. 顺序存储</strong><br>　　　　二叉树可以用数组或链接串列来存储，而且如果这是满二叉树，这种方法不会浪费空间。<a href="http://img.blog.csdn.net/20160731220847809" target="_blank" rel="noopener" data-fancybox="group" data-caption="Binary_tree_in_array" class="fancybox"><img alt="Binary_tree_in_array" title="Binary_tree_in_array" data-src="http://img.blog.csdn.net/20160731220847809" class="lazyload"></a>  </li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的顺序存储表示 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">/* 二叉树的最大节点数 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE]; <span class="comment">/* 0号单元存储根节点 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">int</span> level,order; <span class="comment">/* 节点的层，本层序号(按满二叉树计算) */</span></span><br><span class="line">}<span class="built_in">position</span>;</span><br></pre></td></tr></tbody></table></figure></div>

<p>　　　　用这种紧凑排列，如果一个节点的索引为<code>i</code>，它的子节点能在索引<code>2i+1</code>和<code>2i+2</code>找到，并且它的父节点（如果有）能在索引<code>floor((i-1)/2)</code>找到（假设根节点的索引为0）。<br>　　　　这种方法更有利于紧凑存储和更好的访问的局部性，特别是在[前序遍历]中。然而，它需要连续的存储空间，这样在存储高度为h的n个结点组成的一般普通树时将会浪费很多空间。一种最极坏的情况下如果深度为h的二叉树每个节点只有右孩子需要占用2的h次幂减1，而实际却只有h个结点，空间的浪费太大，这是顺序存储结构的一大缺点。<br>　　　　<a href="http://img.blog.csdn.net/20160731220526023" target="_blank" rel="noopener" data-fancybox="group" data-caption="二叉树及节点编号" class="fancybox"><img alt="二叉树及节点编号" title="二叉树及节点编号" data-src="http://img.blog.csdn.net/20160731220526023" class="lazyload"></a><br>　　　　将数组下标作为结点名称(编号)，就可将二叉树中所有结点的标号存储在一维数组中。<br>　　　　<a href="http://img.blog.csdn.net/20160731220658389" target="_blank" rel="noopener" data-fancybox="group" data-caption="二叉树的顺序存储结构" class="fancybox"><img alt="二叉树的顺序存储结构" title="二叉树的顺序存储结构" data-src="http://img.blog.csdn.net/20160731220658389" class="lazyload"></a><br>　　　　在二叉树的这种表示方式下，各结点之间的逻辑关系是隐含表示的。近似满二叉树中，除最下面一层外，各层都充满了结点。可能除最底层外，每一层的结点个数恰好是上一层结点个数的2倍。因此，从一个结点的编号就可推知其父亲，左、右儿子，和兄弟等结点的编号。例如，对于结点<code>i</code>我们有：</p>
<ol>
<li>仅当i=1时，结点i为根结点；</li>
<li>当i>1时，结点i的父结点为i/2；</li>
<li>结点i的左儿子结点为2i；</li>
<li>结点i的右儿子结点为2i+1；</li>
<li>当i为奇数且不为1时，结点i的左兄弟结点为i-1；</li>
<li>当i为偶数时，结点i的右兄弟结点为i+1。<br>由上述关系可知，近似满二叉树中结点的层次关系足以反映结点之间的逻辑关系。因此，对近似满二叉树而言，顺序存储结构既简单又节省存储空间。</li>
</ol>
<p>对于一般的二叉树，采用顺序存储时，为了能用结点在数组中的位置来表示结点之间的逻辑关系，也必须按近似满二叉树的形式来存储树中的结点。显然，这将造成存储空间的浪费。在最坏情况下，一个只有k个结点的右单枝树却需要2k-1个结点的存储空间。<br>例如，只有3个结点的右单枝树，如下图(a)所示，添上一些实际不存在的虚结点后，成为一棵近似满二叉树，相应的顺序存储结构如下图(b)所示。<br><a href="http://img.blog.csdn.net/20160731222123146" target="_blank" rel="noopener" data-fancybox="group" data-caption="一般二叉树" class="fancybox"><img alt="一般二叉树" title="一般二叉树" data-src="http://img.blog.csdn.net/20160731222123146" class="lazyload"></a></p>
<ul>
<li><p><strong>2. 二叉树的结点度表示法</strong><br>　　二叉树的顺序存储结构可看作是二叉树的一种无边表示，即树中边信息是隐含的。二叉树的另一种无边表示称为二叉树的结点度表示。这种表示法将二叉树中所有结点依其后序列表排列，并在每个结点中附加一个0到3之间的整数，以表示结点的状态。该整数为0时，表示相应的结点为一叶结点；为1时，表示相应结点只有一个左儿子；为2时，表示相应结点只有一个右儿子；为3时，表示相应结点有两个儿子。例如，图(a)中的二叉树的结点度表示如图(b)所示。<br><a href="http://img.blog.csdn.net/20160731225454521" target="_blank" rel="noopener" data-fancybox="group" data-caption="二叉树节点度表示" class="fancybox"><img alt="二叉树节点度表示" title="二叉树节点度表示" data-src="http://img.blog.csdn.net/20160731225454521" class="lazyload"></a></p>
</li>
<li><p><strong>3.  二叉树的链式存储结构</strong><br>　　在使用记录或内存地址指针的程序设计语言中，二叉树通常用树结点结构来存储。有时也包含指向唯一的父节点的指针。如果一个结点的子结点个数小于2，一些子结点指针可能为空值，或者为特殊的哨兵结点。 使用链表能避免顺序存储浪费空间的问题，算法和结构相对简单，但使用二叉链表，由于缺乏父链的指引，在找回父节点时需要重新扫描树得知父节点的节点地址。   
　　</p>
</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 二叉树的二叉链表存储表示 */</span><br><span class="line"> typedef struct BiTNode</span><br><span class="line"> {</span><br><span class="line">   TElemType data;</span><br><span class="line">   struct BiTNode *lchild, /* 左孩子指針 */</span><br><span class="line">   struct BiTNode *rchild; /* 右孩子指針 */</span><br><span class="line"> }BiTNode,*BiTree;</span><br></pre></td></tr></tbody></table></figure></div>

<p>　　<a href="http://img.blog.csdn.net/20160731225720975" target="_blank" rel="noopener" data-fancybox="group" data-caption="指针实现二叉链表树" class="fancybox"><img alt="指针实现二叉链表树" title="指针实现二叉链表树" data-src="http://img.blog.csdn.net/20160731225720975" class="lazyload"></a><br>　　<br>　　<a href="http://img.blog.csdn.net/20160731225804563" target="_blank" rel="noopener" data-fancybox="group" data-caption="游标实现二叉链表树" class="fancybox"><img alt="游标实现二叉链表树" title="游标实现二叉链表树" data-src="http://img.blog.csdn.net/20160731225804563" class="lazyload"></a><br>　　<br>　　<a href="http://img.blog.csdn.net/20160731230554682" target="_blank" rel="noopener" data-fancybox="group" data-caption="基于链表的二叉树逻辑结构示意" class="fancybox"><img alt="基于链表的二叉树逻辑结构示意" title="基于链表的二叉树逻辑结构示意" data-src="http://img.blog.csdn.net/20160731230554682" class="lazyload"></a></p>
<ul>
<li><strong>4. 三叉链表存储表示</strong><br>　　改进于二叉链表，增加父节点的指引，能更好地实现节点间的访问，不过算法相对复杂。 当二叉树用三叉链表表示时，有N个结点，就会有N+2个空指针。
　　</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 二叉树的三叉链表存储表示 */</span><br><span class="line"> typedef struct BiTPNode</span><br><span class="line"> {</span><br><span class="line">   TElemType data;</span><br><span class="line">   struct BiTPNode *parent; /* 父孩子指針 */</span><br><span class="line">   struct BiTPNode *lchild; /* 左孩子指針 */</span><br><span class="line">   struct BiTPNode *rchild; /* 右孩子指針 */</span><br><span class="line"> }BiTPNode,*BiPTree;</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="http://img.blog.csdn.net/20160731230420711" target="_blank" rel="noopener" data-fancybox="group" data-caption="三叉链表" class="fancybox"><img alt="三叉链表" title="三叉链表" data-src="http://img.blog.csdn.net/20160731230420711" class="lazyload"></a></p>
<h2 id="四．二叉树的遍历"><a href="#四．二叉树的遍历" class="headerlink" title="四．二叉树的遍历"></a>四．二叉树的遍历</h2><p>　　<br>　　我们经常希望访问树中的每一个结点并且查看它的值。有很多常见的顺序来访问所有的结点，而且每一种都有有用的性质。<br>　　由于二叉树的定义是递归的，因此一棵非空二叉树可以看作是由根节点，左子树和右子树这三个基本部分组成．如果能依次遍历这三个部分的信息，也就遍历了整个二叉树．因此，二叉树的遍历就是按某种策略访问二叉树中每一个节点并且访问一次的过程．<br>　　若以字母ＤＬＲ分别表示访问根节点，遍历根节点的左子树，遍历根节点的右子树，则二叉树的遍历方式有六种：DLR,LDR,LRD,DRL,RDL和RLD．如果限定先左后右则只有前三种方式：DLR,LDR和LRD，分别被称之为先序(前序)遍历，中序遍历和后序遍历．<br>　　遍历二叉树的实质就是对二叉树线性化的过程．即遍历的结果是将非线性结构中的节点排成一个线性序列，而且三种遍历的结果都是线性序列．遍历二叉树的基本操作就是访问节点，对含有n个节点的二叉树不论按哪种次序遍历，其时间复杂度均为O(n),这是因为在遍历过程中实际是按照节点的左右指针遍历二叉树的每一个节点．此外，遍历所需的辅助空间为栈的容量，在遍历过程中每递归调用一次都要将有关节点的信息压入栈中，栈的容量恰为树的深度，最坏情况是n个节点的单支树，这时树的深度为n，所以空间复杂度为O(n).<br>　　二叉树三种遍历的方法如表所示．</p>
<table>
<thead>
<tr>
<th>遍历方式</th>
<th>操作步骤</th>
</tr>
</thead>
<tbody><tr>
<td>先序遍历</td>
<td>若二叉树非空：</td>
</tr>
<tr>
<td></td>
<td>1.访问根节点 2.按先序遍历左子树 3.按先序遍历右子树</td>
</tr>
<tr>
<td>中序便利</td>
<td>若二叉树非空：</td>
</tr>
<tr>
<td></td>
<td>1. 按中序遍历左子树 2.访问根节点　3.按中序遍历右子树</td>
</tr>
<tr>
<td>后序便利</td>
<td>若二叉树非空：</td>
</tr>
<tr>
<td></td>
<td>1. 按后序遍历左子树 2.按后序遍历右子树 3.访问根节点</td>
</tr>
</tbody></table>
<p>此外，二叉树的遍历还可以采用层次遍历的方法．　　</p>
<p>　　<a href="http://img.blog.csdn.net/20160801191717912" target="_blank" rel="noopener" data-fancybox="group" data-caption="遍历例２" class="fancybox"><img alt="遍历例２" title="遍历例２" data-src="http://img.blog.csdn.net/20160801191717912" class="lazyload"></a></p>
<p>　　<a href="http://img.blog.csdn.net/20160801184835045" target="_blank" rel="noopener" data-fancybox="group" data-caption="binary_tree" class="fancybox"><img alt="binary_tree" title="binary_tree" data-src="http://img.blog.csdn.net/20160801184835045" class="lazyload"></a><br>　　前序遍历：abdefgc<br>　　中序遍历：debgfac<br>　　后序遍历：edgfbca</p>
<h3 id="I-遍历二叉树的递归算法及遍历示例"><a href="#I-遍历二叉树的递归算法及遍历示例" class="headerlink" title="I. 遍历二叉树的递归算法及遍历示例"></a><strong>I. 遍历二叉树的递归算法及遍历示例</strong></h3><ul>
<li><p>1.　先序遍历二叉树的递归算法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Preorder(BSTree *p)　　    //先序遍历二叉树</span><br><span class="line">{</span><br><span class="line">     if(NULL != p)</span><br><span class="line">     {</span><br><span class="line">         printf("%3c",p->data);  //访问根节点</span><br><span class="line">         Preorder(p->lchild);    //先序遍历左子树</span><br><span class="line">         Preorder(p->rchild);    //先序遍历右子树</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
</li>
<li><p>2.　中序遍历二叉树的递归算法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Inorder(BSTree *p)　  　    //中序遍历二叉树</span><br><span class="line">{</span><br><span class="line">     if(NULL != p)</span><br><span class="line">     {</span><br><span class="line">         Inorder(p->lchild);     //中序遍历左子树</span><br><span class="line">         printf("%3c",p->data);  //访问根节点      </span><br><span class="line">         Inorder(p->rchild);     //中序遍历右子树</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
</li>
<li><p>3.　后序遍历二叉树的递归算法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Postorder(BSTree *p)　    　  //后序遍历二叉树</span><br><span class="line">{</span><br><span class="line">     if(NULL != p)</span><br><span class="line">     {</span><br><span class="line">         Postorder(p->lchild);     //后序遍历左子树</span><br><span class="line">         Postorder(p->rchild);     //后序遍历右子树</span><br><span class="line">         printf("%3c",p->data);    //访问根节点      </span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p> 　</p>
</li>
</ul>
<h3 id="II-遍历二叉树的非递归算法"><a href="#II-遍历二叉树的非递归算法" class="headerlink" title="II.遍历二叉树的非递归算法"></a><strong>II.遍历二叉树的非递归算法</strong></h3><p>　　递归算法虽然简洁，但可读性较差且执行效率不高．因此，就存在着如何把遍历二叉树的递归算法转化为非递归算法的问题．<br>　　由二叉树的遍历可知，先序，中序和后序遍历都是从根节点开始的，并且在遍历过程中所经历的节点路线都是一样的，只不过访问节点信息的时机不同．也即，二叉树的遍历路线是从根节点开始沿左子树向下深入，当深入到最左端节点时，则因无法继续深入下去而返回，然后再逐一进入刚才深入时所遇节点的右子树，并且重复前面深入和返回的过程，直到最后从根节点的右子树返回到根节点时为止．由于节点返回的顺序正好和节点深入的顺序相反，即后深入先返回，它恰好符合栈结构的后进先入特点，因此可以用栈来实现遍历二叉树的非递归算法．注意，在三种便利方式中，先序遍历是在深入过程中饭凡遇到节点就访问该节点信息，中序遍历则是从左子树返回时访问该节点信息，而后序遍历是从右子树返回时访问节点信息．</p>
<ul>
<li>1.　先序遍历二叉树的非递归算法<br>　　先序非递归遍历二叉树的方法是：由根节点沿左子树(即p->lchild`所指)一直遍历下去，在遍历过程中每经过一个节点时就输出(访问)该节点的信息并且同时将其压栈，当某个节点无左子树时就将这个节点由栈中弹出，并由这个节点的右子树的根开始继续沿其左子树向下遍历(对此时右子树的根节点也进行输出和压栈操作)，直到栈中无任何节点时就实现了先序遍历．先序遍历的非递归算法如下：
　　</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Preorder(BSTree *p)           //先序遍历二叉树</span><br><span class="line">{</span><br><span class="line">    BSTree *stack[MAXSIZE];        //MAXSIZE为大于二叉树节点个数的容量</span><br><span class="line">    int i = 0;</span><br><span class="line">    stack[0] = NULL;               //栈初始化</span><br><span class="line">    while(p!= NULL || i>0)         //当指针p不为空或栈stack不空(i>0)时</span><br><span class="line">    {</span><br><span class="line">        if(p!=NULL)                //当指针p不为空时</span><br><span class="line">        {</span><br><span class="line">            printf("%3c", p->data);//输出该节点信息</span><br><span class="line">            stack[++i] = p;        //将该节点压栈</span><br><span class="line">            p = p->lchild;         //沿左子树向下遍历</span><br><span class="line">        }</span><br><span class="line">        else                       //当指针p为空时</span><br><span class="line">        {</span><br><span class="line">            p = stack[i--];        //将这个无左子树的节点由栈中弹出</span><br><span class="line">            p = p->rchild;         //从该节点右子树的根开始沿左子树向下遍历</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<ul>
<li>2.　中序遍历二叉树的非递归算法<br>　　中序非递归遍历二叉树与先序非递归遍历二叉树的过程基本相同，仅是输出节点信息的语句位置发生了变化，即每当需要沿当前节点的右子树根开始继续沿其左子树向下遍历时(即此时已经遍历过当前节点的左子树了)，就先输出这个当前节点的信息．中序便利二叉树非递归算法如下：
　　</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Inorder(BSTree *p)            //中序遍历二叉树</span><br><span class="line">{</span><br><span class="line">    BSTree *stack[MAXSIZE];        //MAXSIZE为大于二叉树节点个数的容量</span><br><span class="line">    int i = 0;</span><br><span class="line">    stack[0] = NULL;               //栈初始化</span><br><span class="line">    while(i > 0)         　　　　　　//栈stack不空(i>0)时</span><br><span class="line">    {</span><br><span class="line">        if(p!=NULL)                //当指针p不为空时</span><br><span class="line">        {</span><br><span class="line">            stack[++i] = p;        //将该节点压栈</span><br><span class="line">            p = p->lchild;         //沿左子树向下遍历</span><br><span class="line">        }</span><br><span class="line">        else                       //当指针p为空时</span><br><span class="line">        {</span><br><span class="line">            p = stack[i--];        //将这个无左子树的节点由栈中弹出</span><br><span class="line">            printf("%3c", p->data);//输出该节点信息</span><br><span class="line">            p = p->rchild;         //从该节点右子树的根开始沿左子树向下遍历</span><br><span class="line">        }</span><br><span class="line">        if(p == NULL && i == 0)    //当指针p为空且栈stack也为空时结束循环</span><br><span class="line">            break;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<ul>
<li>3.　后序遍历二叉树的非递归算法<br>　　后序非遍历二叉树与前面两种非递归遍历算法有所不同，它除了使用栈stack之外，还需使用一个数组b来记录二叉树中节点i(i=1,2,3,…n)当前遍历的情况：如果b[i]为0，则表示仅遍历过节点i的左子树，它的右子树还没遍历过；如果b[i]为1，则表示节点i的左右子树都被遍历过～～<br>　　右序非递归便利二叉树的过程仍然是由根节点开始沿左子树向下进行遍历，并且将遇到的所有节点顺序压栈．当某个节点j无左子树时就将节点j由栈stack中弹出，然后检查b[j]是否为0，如果b[j]为0则表示节点j的右子树还未遍历过，也即必须遍历过节点j的右子树后方可输出节点j的信息，所以必须先节点j的右子树，即将节点j重新压栈并置b[j]为1(作为遍历过左右子数的标识)，然后再将节点j的右孩子压栈并沿右孩子的左子树继续向下遍历．直到某一时刻该节点j再次由栈中弹出，因为此时b[j]已经为1，即表示此时节点j的左右子树都已遍历过(节点j的左右子树上的所有节点信息都已经输出)，或者j本身就是一个叶节点，这时就可以输出节点j的信息了．为了统一，对于前者，在输出了节点j的信息后即置节点j的父节点指向节点j的指针值为NULL．这样，当某个节点的左右孩子指针都已为NULL时，则意味着或者该节点本身就为叶节点，或者该节点左右子树中的节点信息都已输出过，此时就可以输出该节点的信息了．后序遍历二叉树非递归算法如下：
　　</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void Postorder(BSTree *p)                //后序遍历二叉树</span><br><span class="line">{</span><br><span class="line">    int i = 0;</span><br><span class="line">    int b[MAXSIZE];                      //数组b用于标识每个节点是否已遍历过其左右子树</span><br><span class="line">    BSTree *stack[MAXSIZE];              //MAXSIZE为大于二叉树节点个数的容量</span><br><span class="line">    stack[0] = NULL;                     //栈初始化</span><br><span class="line">    do</span><br><span class="line">    {</span><br><span class="line">        if(p != NULL)                    //当指针p不为空时</span><br><span class="line">        {</span><br><span class="line">            stack[++i] = p;              //将遍历中遇到的所有节点依次压栈</span><br><span class="line">            b[i] = 0;                    //置该节点右子树未访问过的标志</span><br><span class="line">            p = p->lchild;               //沿该节点左子树继续向下遍历</span><br><span class="line">        }</span><br><span class="line">        else                             //当指针p为空时</span><br><span class="line">        {</span><br><span class="line">            p = stack[i--];              //将这个无左子树(或左子树已遍历过)的当前节点由栈中弹出</span><br><span class="line">            if(!b[i+1])                  //b[i+1]为0则当前节点的右子树未遍历</span><br><span class="line">            {</span><br><span class="line">                stack[++i] = p;          //将当前节点重新压栈</span><br><span class="line">                b[i] = 1;                //置当前节点右子树已访问过标志</span><br><span class="line">                p = p->rchild;           //沿当前节点右孩子继续向下遍历</span><br><span class="line">            }</span><br><span class="line">            else                         //当前节点的左右子树都已遍历(即节点信息都已输出)</span><br><span class="line">            {</span><br><span class="line">                printf("%3c", p->data);  //输出当前节点信息</span><br><span class="line">                p = NULL;                //将指向当前节点的指针置为空</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }while(p != NULL || i > 0)           //当指针p 不空或栈stack不空(i>0)时继续遍历</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>这种后序遍历二叉树的非递归算法，其优点是只需一重循环即可实现，而缺点是遍历之后二叉树就被破坏．另一种不破坏二叉树却需两重循环实现的后序遍历非递归算法如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void Postorder1(BSTree *p)</span><br><span class="line">{</span><br><span class="line">    int b = 0;</span><br><span class="line">    int i = -1;</span><br><span class="line">    BSTree *q ;</span><br><span class="line">    BSTree *stack[MAXSIZE];            //MAXSIZE为大于二叉树节点个数的常量</span><br><span class="line">    do</span><br><span class="line">    {</span><br><span class="line">        while(p != NULL)               //将*p节点左分支上的所有左孩子入栈</span><br><span class="line">        {</span><br><span class="line">            stack[++i] = p;</span><br><span class="line">            p = p->lchild;</span><br><span class="line">        }</span><br><span class="line">        //栈顶节点已没有左孩子或其左子树上的节点都已访问过</span><br><span class="line">        q = NULL;</span><br><span class="line">        b = 1;                         //置已访问过的标记</span><br><span class="line">        while(i >= 0 && b)             //栈stack不空且当前栈顶节点的左子树已经遍历过</span><br><span class="line">        {</span><br><span class="line">            p = stack[i];              //取出当前栈顶节点</span><br><span class="line">            if(p->rchild == q)         //当前栈顶节点*p无右孩子或*p的右孩子已经遍历过</span><br><span class="line">            {</span><br><span class="line">                printf("%3c", p->data);//输出当前节点*p的值</span><br><span class="line">                i --;</span><br><span class="line">                q = p;                 //q指向刚访问过的节点*p</span><br><span class="line">            }</span><br><span class="line">            else                       //当前栈顶节点*p有右子树</span><br><span class="line">            {</span><br><span class="line">                p = p->rchild;         //p指向当前栈顶节点*p的右孩子节点</span><br><span class="line">                b = 0;                 //置该右孩子节点未遍历过其右子树标记</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }while(i >= 0)                     //当栈stack非空时继续遍历</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>算法中，表达式<code>p->rchild == q</code>的含义是：若q等于NULL，则表示节点<code>*p</code>的右孩子不存在且<code>*p</code>的左子树或不存在或已遍历过，所以现在可以访问节点<code>*p</code>了；若q不等于NULL，则表示<code>*p</code>的右孩子已访问过(因为q指向p的右子树中刚被访问过的节点，而<code>*q</code>此时又是<code>*p</code>的右孩子，即意味着p 的右子树中所有节点都已访问过)，所以现在可以访问<code>*p</code>.</p>
<h3 id="III-二叉树的层次遍历算法"><a href="#III-二叉树的层次遍历算法" class="headerlink" title="*III. 二叉树的层次遍历算法 *"></a>*<em>III. 二叉树的层次遍历算法 *</em></h3><p>　　二叉树的层次遍历是指从二叉树的第一层(即根节点开始)，对整棵二叉树进行自上而下的逐层遍历．在同一层中，则按从左到右的顺序逐个访问该层的每一个节点．<br>　　<a href="http://img.blog.csdn.net/20160801191623464" target="_blank" rel="noopener" data-fancybox="group" data-caption="遍历例１" class="fancybox"><img alt="遍历例１" title="遍历例１" data-src="http://img.blog.csdn.net/20160801191623464" class="lazyload"></a><br>　　在进行层次遍历时，对某一层节点访问完后，再按照它们的访问次序对各个节点的左孩子和右孩子顺序访问．这样一层一层的进行，先访问的节点其左右孩子也必定先访问，这恰好与队列的操作相吻合．因此，在进行层次遍历时可设置一个队列结构，遍历从二叉树的根节点开始，即首先访问根节点并同时将根节点的指针t入队，然后在队不为空的情况下循环执行下述操作：<br>　　先从队头取出一个节点<code>*p</code>，若<code>*p</code>有左孩子则访问左孩子并将指向左孩子的指针入队；若<code>*p</code>有右孩子则访问右孩子并将指向右孩子的指针入队．<br>　　这种不断入队，出队的操作一直持续到队空为止，而此时二叉树的所有节点都已遍历．
　　</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transleve</span><span class="params">(BSTree *t)</span>                   <span class="comment">//层次遍历二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SeQueue *Q;</span><br><span class="line">    BSTree *p;</span><br><span class="line">    Init_SeQueue(&Q);                       <span class="comment">//队列Q初始化</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">NULL</span>)                           <span class="comment">//二叉树t非空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2c"</span>, t->data);             <span class="comment">//输出根节点信息</span></span><br><span class="line">    In_SeQueue(Q, t);                       <span class="comment">//指针t 入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Empty_SeQueue(Q))                <span class="comment">//队Q非空</span></span><br><span class="line">    {</span><br><span class="line">        Out_SeQueue(Q, &p);                 <span class="comment">//从头节点(即指针值)出队并赋给p</span></span><br><span class="line">        <span class="keyword">if</span>(p->lchild !=<span class="literal">NULL</span>)                <span class="comment">//*p有左孩子</span></span><br><span class="line">        {</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%2c"</span>, p->lchild->data);  <span class="comment">//输出左孩子信息</span></span><br><span class="line">           In_SeQueue(Q, p->lchild);        <span class="comment">//*p左孩子指针入队</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(p->rchild !=<span class="literal">NULL</span>)                <span class="comment">//*p有右孩子</span></span><br><span class="line">        {</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%2c"</span>, p->rchild->data);  <span class="comment">//输出右孩子信息</span></span><br><span class="line">           In_SeQueue(Q, p->rchild);        <span class="comment">//*p右孩子指针入队</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="五．二叉树的操作接口及程序代码"><a href="#五．二叉树的操作接口及程序代码" class="headerlink" title="五．二叉树的操作接口及程序代码"></a>五．二叉树的操作接口及程序代码</h2><ul>
<li><code>binary_tree.h</code></li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BINARY_TREE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BINARY_TREE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tools.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> END (<span class="meta-string">'#'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ONE (1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree_node</span> <span class="title">Tree_node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree_node</span>{</span></span><br><span class="line">    <span class="keyword">char</span>              data;   <span class="comment">//数据区域</span></span><br><span class="line">    Tree_node * left_child;    </span><br><span class="line">    Tree_node *right_child;</span><br><span class="line">};                 </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Tree_node *Bin_tree;                                                <span class="comment">//二叉树的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//二叉树的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一.创建二叉树</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_tree</span><span class="params">(<span class="keyword">char</span> **str)</span></span>;                                           <span class="comment">//一.1.创建二叉树</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_tree_by_pre_mid</span><span class="params">(<span class="keyword">char</span> *pre_str, <span class="keyword">char</span> *mid_str, <span class="keyword">int</span> length)</span></span>;  <span class="comment">//一.2.通过前序和中序创建二叉树</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_tree_by_mid_last</span><span class="params">(<span class="keyword">char</span> *mid_str, <span class="keyword">char</span> *last_str, <span class="keyword">int</span> length)</span></span>;<span class="comment">//一.3.通过中序和后序创建二叉树  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二.销毁二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_tree</span><span class="params">(Bin_tree *root)</span></span>;                                          <span class="comment">//二.1.销毁二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_tree_nr</span><span class="params">(Bin_tree *root)</span></span>;                                       <span class="comment">//二.2.非递归销毁二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三.遍历二叉树</span></span><br><span class="line"><span class="comment">//        A      |      A</span></span><br><span class="line"><span class="comment">//       / \     |     / \</span></span><br><span class="line"><span class="comment">//      B   C    |    C   B</span></span><br><span class="line"><span class="comment">//     / \   \   |   /   / \</span></span><br><span class="line"><span class="comment">//    D   E   F  |  F   E   D      //镜像</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    先序（根、左、右）  A  B  D  E  C  F</span></span><br><span class="line"><span class="comment">//    中序（左、根、右）  D  B  E  A  C  F</span></span><br><span class="line"><span class="comment">//    后序（左、右、根）  D  E  B  F  C  A</span></span><br><span class="line"><span class="comment">//    层序 （1----h）    A  B  C  D  E  F</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_print</span><span class="params">(Bin_tree root)</span></span>;                                        <span class="comment">//三.1.前序递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_order_print</span><span class="params">(Bin_tree root)</span></span>;                                        <span class="comment">//三.2.中序递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_print</span><span class="params">(Bin_tree root)</span></span>;                                       <span class="comment">//三.3.后序递归遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_print_nr</span><span class="params">(Bin_tree root)</span></span>;                                     <span class="comment">//三.4.前序非递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mid_order_print_nr</span><span class="params">(Bin_tree root)</span></span>;                                     <span class="comment">//三.5.中序非递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_print_nr</span><span class="params">(Bin_tree root)</span></span>;                                    <span class="comment">//三.6.后序非递归遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_print</span><span class="params">(Bin_tree root)</span></span>;                                      <span class="comment">//三.7.层序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四.二叉树的性质</span></span><br><span class="line"><span class="function">Boolean <span class="title">is_full_binary_tree</span><span class="params">(Bin_tree root)</span></span>;                                 <span class="comment">//四.1.判断是否是满二叉树</span></span><br><span class="line"><span class="function">Boolean <span class="title">is_complete_binary_tree</span><span class="params">(Bin_tree root)</span></span>;                             <span class="comment">//四.2.判断是否是完全二叉树</span></span><br><span class="line"><span class="function">Boolean <span class="title">is_balance_binary_tree</span><span class="params">(Bin_tree root)</span></span>;                              <span class="comment">//四.3.判断是否是平衡二叉树</span></span><br><span class="line"><span class="function">Boolean <span class="title">is_include_tree</span><span class="params">(Bin_tree root1,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Bin_tree root2)</span></span>;                                    <span class="comment">//四.4.判断二叉树是否包含</span></span><br><span class="line"><span class="function">Boolean <span class="title">is_binarytree_equal</span><span class="params">(Bin_tree root1,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Bin_tree root2)</span></span>;                                <span class="comment">//四.5.判断二叉树是否相等</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//五.二叉树的变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_left_right</span><span class="params">(Bin_tree root)</span></span>;                                        <span class="comment">//五.1.得到二叉树的镜像</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_binarytree_height</span><span class="params">(Bin_tree root)</span></span>;                                   <span class="comment">//五.2.得到二叉树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_largest_dir_count</span><span class="params">(Bin_tree root)</span></span>;                                   <span class="comment">//五.3.得到二叉树的最大路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_binarytree_node_count</span><span class="params">(Bin_tree root)</span></span>;                               <span class="comment">//五.4.得到二叉树的节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_binarytree_leaf_count</span><span class="params">(Bin_tree root)</span></span>;                               <span class="comment">//五.5.得到二叉树的叶子节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_binarytree_level_count</span><span class="params">(Bin_tree root, <span class="keyword">int</span> level)</span></span>;                   <span class="comment">//五.6.得到指定层级的节点个数</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">copy_binary_tree</span><span class="params">(Bin_tree root)</span></span>;                                   <span class="comment">//五.7.二叉树的拷贝</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//六.二叉树的查找</span></span><br><span class="line"><span class="function">Tree_node *<span class="title">find_value</span><span class="params">(Bin_tree root, <span class="keyword">char</span> value)</span></span>;                           <span class="comment">//六.1.找到指定值所在的节点</span></span><br><span class="line"><span class="function">Tree_node *<span class="title">find_parent</span><span class="params">(Bin_tree root,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Tree_node *node)</span></span>;                                    <span class="comment">//六.2.找到指定节点的双亲节点</span></span><br><span class="line"><span class="function">Tree_node *<span class="title">find_common_node</span><span class="params">(Bin_tree root, Tree_node *node1,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Tree_node *node2 )</span></span>;                             <span class="comment">//六.3.找到两个节点的最近公共节点</span></span><br><span class="line">                      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="六-二叉树操作接口实现："><a href="#六-二叉树操作接口实现：" class="headerlink" title="六.二叉树操作接口实现："></a>六.二叉树操作接口实现：</h2><ul>
<li><code>binary_tree.c</code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非操作接口声明及实现</span></span><br><span class="line"><span class="comment">//二叉树的接口</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Tree_node *<span class="title">create_node</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">char</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Bin_tree root)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Tree_node *<span class="title">find_common</span><span class="params">(Bin_tree root,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Tree_node *node1, Tree_node *node2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> b > a ? b : a;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Tree_node *<span class="title">create_node</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *node = (Tree_node *)Malloc(<span class="keyword">sizeof</span>(Tree_node));</span><br><span class="line">    bzero(node, <span class="keyword">sizeof</span>(Tree_node));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//获得索引</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_index</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">char</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// abcdefg</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     e</span></span><br><span class="line">    <span class="keyword">char</span> *local = <span class="built_in">strchr</span>(<span class="built_in">string</span>, value);</span><br><span class="line">    <span class="keyword">return</span> local == <span class="literal">NULL</span> ? <span class="number">-1</span> : (local - <span class="built_in">string</span>) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li>
</ul>
<p><strong>一．创建二叉树</strong></p>
<ul>
<li>(1.普通string创建，2.先序中序，3.中序后序)<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一.创建二叉树</span></span><br><span class="line"><span class="comment">//Bin_tree create_tree(char **str);    　　　　　　　　　　　　　　　　　</span></span><br><span class="line"><span class="comment">//                  A</span></span><br><span class="line"><span class="comment">//                /   \</span></span><br><span class="line"><span class="comment">//               B     G   </span></span><br><span class="line"><span class="comment">//              / \    / \</span></span><br><span class="line"><span class="comment">//             C   D  H   J</span></span><br><span class="line"><span class="comment">//                / \  \</span></span><br><span class="line"><span class="comment">//               E   F  I</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//       ABC##DE##F##GH#I##J##</span></span><br><span class="line"><span class="comment">//       A</span></span><br><span class="line"><span class="comment">//       A->left   = BC##DE##F##GH#I##J##</span></span><br><span class="line"><span class="comment">//                   B->left  = C##DE ..</span></span><br><span class="line"><span class="comment">//                              C->left  = # = NULL</span></span><br><span class="line"><span class="comment">//                              C->rigth = # = NULL</span></span><br><span class="line"><span class="comment">//                   B->rigth = DE##F ..</span></span><br><span class="line"><span class="comment">//                              D ->left  = E##F#..</span></span><br><span class="line"><span class="comment">//                                          E->left  = # = NULL</span></span><br><span class="line"><span class="comment">//                                          E->rigth = # = NULL</span></span><br><span class="line"><span class="comment">//                              D ->right = F##GH..</span></span><br><span class="line"><span class="comment">//                                          F ->left = # = NULL</span></span><br><span class="line"><span class="comment">//                                          F ->right= # = NULL</span></span><br><span class="line"><span class="comment">//       A ->rigth = GH#I..</span></span><br><span class="line"><span class="comment">//                   G ->left  = H#I..</span></span><br><span class="line"><span class="comment">//                               H->left  = # = NULL</span></span><br><span class="line"><span class="comment">//                               H->rigth = I##J</span></span><br><span class="line"><span class="comment">//                                          I->left  = # =NULL</span></span><br><span class="line"><span class="comment">//                                          I->rigth = # = NULL</span></span><br><span class="line"><span class="comment">//                   G ->rigth = J##</span></span><br><span class="line"><span class="comment">//                               J ->left = NULL</span></span><br><span class="line"><span class="comment">//                               J->rigth = NULL</span></span><br><span class="line"><span class="comment">//                       </span></span><br><span class="line"><span class="comment">//                      </span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_tree</span><span class="params">(<span class="keyword">char</span> **str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Bin_tree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">NULL</span> && *str != <span class="literal">NULL</span> && **str != END){</span><br><span class="line">        root = create_node();  </span><br><span class="line">        root->data = **str;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//处理完当前节点，然后递归地创建其左右孩子</span></span><br><span class="line">        <span class="comment">//++*str;</span></span><br><span class="line">        (*str)++;</span><br><span class="line">        root->left_child = create_tree(str);</span><br><span class="line">        <span class="comment">//++*str;</span></span><br><span class="line">        (*str)++;</span><br><span class="line">        root->right_child = create_tree(str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//一.2.通过前序和中序创建二叉树</span></span><br><span class="line"><span class="comment">//Bin_tree create_tree_by_pre_mid(char *pre_str, char *mid_str, int length);  </span></span><br><span class="line"><span class="comment">//                  A</span></span><br><span class="line"><span class="comment">//                /   \</span></span><br><span class="line"><span class="comment">//               B     G   </span></span><br><span class="line"><span class="comment">//              / \    / \</span></span><br><span class="line"><span class="comment">//             C   D  H   J</span></span><br><span class="line"><span class="comment">//                / \  \</span></span><br><span class="line"><span class="comment">//               E   F  I</span></span><br><span class="line"><span class="comment">//     先序： ABCDEFGHIJ    确定当前序列中根地位置</span></span><br><span class="line"><span class="comment">//     中序： CBEDFAHIGJ    得到某个节点地左右子树部分</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     1.先序确定出 A 为根，则CBEDF为左子树内容，HIGJ为右子树内容</span></span><br><span class="line"><span class="comment">//     先序： (A)  BCDEF GHIJ</span></span><br><span class="line"><span class="comment">//     中序： CBEDF (A)  HIGJ   </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//               A</span></span><br><span class="line"><span class="comment">//             /   \</span></span><br><span class="line"><span class="comment">//          CBEDF  HIGJ</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     2.先序中确定 B 为A的左子树的根，则C为B左子树内容，EDF为B右子树内容,</span></span><br><span class="line"><span class="comment">//       且，通过先序中剩下的元素可知，G为A的右子树的根．且HI为G的左子树，J为G的右子树，即</span></span><br><span class="line"><span class="comment">//     先序： (A)      [B]CDEF            　[G]HIJ</span></span><br><span class="line"><span class="comment">//     中序：        C [B] EDF    (A)     HI[G]J   </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//              A</span></span><br><span class="line"><span class="comment">//            /   \</span></span><br><span class="line"><span class="comment">//           B     G</span></span><br><span class="line"><span class="comment">//          / \   / \</span></span><br><span class="line"><span class="comment">//         C EDF HI  J</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     3.先序中确定 C 为B左子树的根，则D为B右子树的根，E为D左子树内容,F为D右子树内容，</span></span><br><span class="line"><span class="comment">//       且，通过先序中剩下的元素可知，H是G为左子树的根．且J为G的右子树，I为H的右子树，即</span></span><br><span class="line"><span class="comment">//     先序： (A)      [B]C D E F            　[G]H IJ</span></span><br><span class="line"><span class="comment">//     中序：        C [B]  E D F    (A)     H I[G]J   </span></span><br><span class="line"><span class="comment">//              A</span></span><br><span class="line"><span class="comment">//            /   \</span></span><br><span class="line"><span class="comment">//           B     G</span></span><br><span class="line"><span class="comment">//          / \   / \</span></span><br><span class="line"><span class="comment">//         C   D H   J</span></span><br><span class="line"><span class="comment">//            / \ \</span></span><br><span class="line"><span class="comment">//           E  F  I</span></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_tree_by_pre_mid</span><span class="params">(<span class="keyword">char</span> *pre_str, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">char</span> *mid_str, <span class="keyword">int</span> length)</span>    <span class="comment">//通过先序和中序构建二叉树</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//     先序： ABCDEFGHIJ    确定当前序列中根地位置</span></span><br><span class="line">    <span class="comment">//     中序： CBEDFAHIGJ    得到某个节点地左右子树部分</span></span><br><span class="line">    Bin_tree root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> root_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre_str == <span class="literal">NULL</span> || mid_str == <span class="literal">NULL</span> || length <= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    root_value = pre_str[<span class="number">0</span>];    <span class="comment">//获取当前序列地根节点数值</span></span><br><span class="line">    root = create_node();</span><br><span class="line">    root->data = root_value;</span><br><span class="line">   </span><br><span class="line">    index = get_index(mid_str, root_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建完根结点后递归处理其左右子树序列</span></span><br><span class="line">    root->left_child = create_tree_by_pre_mid(pre_str + <span class="number">1</span>, mid_str, index);</span><br><span class="line">    root->right_child = create_tree_by_pre_mid(pre_str + index + <span class="number">1</span>, </span><br><span class="line">                                               mid_str + index + <span class="number">1</span>,   </span><br><span class="line">                                               length - index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;    </span><br><span class="line">}</span><br><span class="line"><span class="comment">//一.3.通过中序和后序创建二叉树  </span></span><br><span class="line"><span class="comment">//Bin_tree create_tree_by_mid_last(char *mid_str, char *last_str, int length);</span></span><br><span class="line"><span class="comment">//                  A</span></span><br><span class="line"><span class="comment">//                /   \</span></span><br><span class="line"><span class="comment">//               B     G   </span></span><br><span class="line"><span class="comment">//              / \    / \</span></span><br><span class="line"><span class="comment">//             C   D  H   J</span></span><br><span class="line"><span class="comment">//                / \  \</span></span><br><span class="line"><span class="comment">//               E   F  I</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     中序： CBEDFAHIGJ    得到某个节点地左右子树部分</span></span><br><span class="line"><span class="comment">//     后序： CEFDBIHJGA</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     1.后序确定出 A 为根，则CBEDF为左子树内容，HIGJ为右子树内容</span></span><br><span class="line"><span class="comment">//     中序： CBEDF (A)  HIGJ   </span></span><br><span class="line"><span class="comment">//     后序： CEFDB  IHJG (A)</span></span><br><span class="line"><span class="comment">//               A</span></span><br><span class="line"><span class="comment">//             /   \</span></span><br><span class="line"><span class="comment">//          CBEDF  HIGJ</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     2.后序中确定  G为A的右子树的根. 后序中确定 B 为A的左子树的根,</span></span><br><span class="line"><span class="comment">//       中序： C [B] EDF    (A)     HI [G] J   </span></span><br><span class="line"><span class="comment">//       后序： CEFD[B]     IHJ[G]       (A)</span></span><br><span class="line"><span class="comment">//       C为B的左子树，EDF为B的右子树；J为G的右子树，HI为G的左子树．</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//              A</span></span><br><span class="line"><span class="comment">//            /   \</span></span><br><span class="line"><span class="comment">//           B     G</span></span><br><span class="line"><span class="comment">//          / \   / \</span></span><br><span class="line"><span class="comment">//         C EDF HI  J</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     3.后序中判断出D是B的右子树根节点，且E为D的左子树，F为D的右子树．</span></span><br><span class="line"><span class="comment">//       Ｈ，从后序中看出H是G的左子树根节点，且I为其右子树．</span></span><br><span class="line"><span class="comment">//       中序： C [B] E｛D｝F    (A)     ｛H｝I [G] J   </span></span><br><span class="line"><span class="comment">//       后序： CEF｛D｝[B]     I｛H｝J[G]       (A)</span></span><br><span class="line"><span class="comment">//              A</span></span><br><span class="line"><span class="comment">//            /   \</span></span><br><span class="line"><span class="comment">//           B     G</span></span><br><span class="line"><span class="comment">//          / \   / \</span></span><br><span class="line"><span class="comment">//         C   D H   J</span></span><br><span class="line"><span class="comment">//            / \ \</span></span><br><span class="line"><span class="comment">//           E  F  I</span></span><br><span class="line"></span><br><span class="line"><span class="function">Bin_tree <span class="title">create_tree_by_mid_last</span><span class="params">(<span class="keyword">char</span> *mid_str, <span class="keyword">char</span> *last_str, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//     中序： CBEDFAHIGJ    得到某个节点地左右子树部分</span></span><br><span class="line">    <span class="comment">//     后序： CEFDBIHJGA    得到根节点</span></span><br><span class="line">    Bin_tree root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> root_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(last_str == <span class="literal">NULL</span> || mid_str == <span class="literal">NULL</span> || length <= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    root_value = last_str[length <span class="number">-1</span>];    <span class="comment">//获取当前序列地根节点数值</span></span><br><span class="line">    root = create_node();</span><br><span class="line">    root->data = root_value;</span><br><span class="line">   </span><br><span class="line">    index = get_index(mid_str, root_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建完根结点后递归处理其左右子树序列</span></span><br><span class="line">    root->left_child = create_tree_by_mid_last(mid_str , last_str, index);</span><br><span class="line">    root->right_child = create_tree_by_mid_last(mid_str  + index +<span class="number">1</span>, </span><br><span class="line">                                                last_str + index ,   </span><br><span class="line">                                               length - index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li>
</ul>
<p><strong>二．销毁二叉树</strong></p>
<ul>
<li>递归／非递归</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二.销毁二叉树</span></span><br><span class="line"><span class="comment">//void destroy_tree(Bin_tree *root);                                          </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_tree</span><span class="params">(Bin_tree *root)</span>   </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || *root == <span class="literal">NULL</span>){</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    destroy(*root);</span><br><span class="line">    *root = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Bin_tree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>){</span><br><span class="line">        destroy(root->left_child);  </span><br><span class="line">        destroy(root->right_child);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//二.2.非递归销毁二叉树</span></span><br><span class="line"><span class="comment">//void destroy_tree_nr(Bin_tree *root);                         </span></span><br><span class="line"><span class="comment">//思路：</span></span><br><span class="line"><span class="comment">//               </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//          A      </span></span><br><span class="line"><span class="comment">//         / \</span></span><br><span class="line"><span class="comment">//        B   C    </span></span><br><span class="line"><span class="comment">//       / \   \</span></span><br><span class="line"><span class="comment">//      D   E   F  </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                   A                     B          C</span></span><br><span class="line"><span class="comment">//      | A |      | B |      | B |      | C |      | D |      | D |      | E |      | F |      |   |</span></span><br><span class="line"><span class="comment">//      |   |      | C |      | C |      | D |      | E |      | E |      | F |      |   |      |   |</span></span><br><span class="line"><span class="comment">//      |   |      |   |      |   |      | E |      |   |      | F |      |   |      |   |      |   |</span></span><br><span class="line"><span class="comment">//      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |</span></span><br><span class="line"><span class="comment">//      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//      在销毁n层节点之前，首先把n + 1的节点入队进行地址保存</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_tree_nr</span><span class="params">(Bin_tree *root)</span>   <span class="comment">//非递归销毁二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Queue *<span class="built_in">queue</span> = init_queue();</span><br><span class="line">    Tree_node *p_node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || *root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> ;    </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p_node = *root;</span><br><span class="line">    *root = <span class="literal">NULL</span>;</span><br><span class="line">    in_queue(<span class="built_in">queue</span>, p_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!is_queue_empty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">         get_front_queue(<span class="built_in">queue</span>, (<span class="keyword">void</span> **)&p_node);</span><br><span class="line">         out_queue(<span class="built_in">queue</span>);</span><br><span class="line">       </span><br><span class="line">         <span class="comment">//先记录p_node对应的下一层节点的地址，再销毁p_node</span></span><br><span class="line">         <span class="keyword">if</span>(p_node->left_child != <span class="literal">NULL</span>)</span><br><span class="line">         {</span><br><span class="line">             in_queue(<span class="built_in">queue</span>, p_node->left_child);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(p_node->right_child != <span class="literal">NULL</span>)</span><br><span class="line">         {</span><br><span class="line">             in_queue(<span class="built_in">queue</span>, p_node->right_child);</span><br><span class="line">         }</span><br><span class="line">         </span><br><span class="line">         <span class="built_in">free</span>(p_node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    destroy_queue(&<span class="built_in">queue</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>三．遍历二叉树</strong></p>
<p>1.前序递归遍历,2.中序递归遍历,3.后序递归遍历<br>4.前序非递归遍历,5.中序非递归遍历,6.后序非递归遍历<br>7.层序遍历</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line">//三.遍历二叉树</span><br><span class="line">//        A      |      A</span><br><span class="line">//       / \     |     / \</span><br><span class="line">//      B   C    |    C   B</span><br><span class="line">//     / \   \   |   /   / \</span><br><span class="line">//    D   E   F  |  F   E   D</span><br><span class="line">//</span><br><span class="line">//    先序（根、左、右）  A  B  D  E  C  F</span><br><span class="line">//    中序（左、根、右）  D  B  E  A  C  F</span><br><span class="line">//    后序（左、右、根）  D  E  B  F  C  A</span><br><span class="line">//    层序 （1----h）     A  B  C  D  E  F</span><br><span class="line">//                  A</span><br><span class="line">//                /   \</span><br><span class="line">//               B     G   </span><br><span class="line">//              / \    / \</span><br><span class="line">//             C   D  H   J</span><br><span class="line">//                / \  \</span><br><span class="line">//               E   F  I</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//     先序： ABCDEFGHIJ    确定当前序列中根地位置</span><br><span class="line">//     中序： CBEDFAHIGJ    得到某个节点地左右子树部分</span><br><span class="line">//     后序： CEFDBIHJGA</span><br><span class="line">//</span><br><span class="line">//////////////////////////////////////////////////////////////////</span><br><span class="line">//</span><br><span class="line">//                     A</span><br><span class="line">//                    / \</span><br><span class="line">//                   B   C</span><br><span class="line">//                  / \</span><br><span class="line">//                 D   E</span><br><span class="line">//</span><br><span class="line">//               ABDEC   pre</span><br><span class="line">//               DEBCA   last</span><br><span class="line">////////////////////////////////////////////////////////////////////</span><br><span class="line">//</span><br><span class="line">//                  A</span><br><span class="line">//                 /                        </span><br><span class="line">//                B</span><br><span class="line">//               / \</span><br><span class="line">//              D   E    </span><br><span class="line">//                          </span><br><span class="line">//         ABDE</span><br><span class="line">//</span><br><span class="line">//         DEBA</span><br><span class="line">//</span><br><span class="line">//                 A            A</span><br><span class="line">//                /              \</span><br><span class="line">//               B                B</span><br><span class="line">//              /                / \</span><br><span class="line">//             D                D   E</span><br><span class="line">//            /                     </span><br><span class="line">//           E                       </span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//三.1.前序递归遍历</span><br><span class="line">//void pre_order_print(Bin_tree root);                                  </span><br><span class="line">void pre_order_print(Bin_tree root)    //前序递归遍历</span><br><span class="line">{</span><br><span class="line">    if(root != NULL){</span><br><span class="line">         printf("%c ", root->data);</span><br><span class="line">         pre_order_print(root->left_child);</span><br><span class="line">         pre_order_print(root->right_child);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//三.2.中序递归遍历</span><br><span class="line">//void mid_order_print(Bin_tree root);                                       </span><br><span class="line">void mid_order_print(Bin_tree root)    //中序递归遍历</span><br><span class="line">{</span><br><span class="line">    if(root != NULL){</span><br><span class="line">         mid_order_print(root->left_child);</span><br><span class="line">         printf("%c ", root->data);</span><br><span class="line">         mid_order_print(root->right_child);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">//三.3.后序递归遍历</span><br><span class="line">//void last_order_print(Bin_tree root);                                       </span><br><span class="line">void last_order_print(Bin_tree root)    //后序递归遍历</span><br><span class="line">{</span><br><span class="line">    if(root != NULL){</span><br><span class="line">         last_order_print(root->left_child);</span><br><span class="line">         last_order_print(root->right_child);</span><br><span class="line">         printf("%c ", root->data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//三.4.前序非递归遍历</span><br><span class="line">//void pre_order_print_nr(Bin_tree root);                                     </span><br><span class="line">//</span><br><span class="line">//                   A</span><br><span class="line">//                /    \</span><br><span class="line">//               B      G   </span><br><span class="line">//              / \    / \</span><br><span class="line">//             C   D  H   J</span><br><span class="line">//                / \  \</span><br><span class="line">//               E   F  I</span><br><span class="line">//</span><br><span class="line">//     先序： ABCDEFGHIJ    确定当前序列中根地位置</span><br><span class="line">//</span><br><span class="line">//     借助栈，在打印当前节点后分别记录其右、左孩子                                                                                </span><br><span class="line">//                                                                                                                                 A</span><br><span class="line">//                                                                                                                      A          B</span><br><span class="line">//                                                                                                           A          B          C</span><br><span class="line">//                                                                                                A          B          C          D</span><br><span class="line">//                                                                                     A          B          C          D          E</span><br><span class="line">//                                                                          A          B          C          D          E          F</span><br><span class="line">//                                                               A          B          C          D          E          F          G</span><br><span class="line">//                                                    A          B          C          D          E          F          G          H</span><br><span class="line">//                              A          A          B          C          D          E          F          G          H          I</span><br><span class="line">//                   A          B          B          C          D          E          F          G          H          I          J</span><br><span class="line">//      | A |      | B |      | G |      | C |      | D |      | E |      | F |      | G |      | H |      | I |      | J |      |   | </span><br><span class="line">//      |   |      | G |      |   |      | D |      | G |      | F |      | G |      |   |      | J |      | J |      |   |      |   |  </span><br><span class="line">//      |   |      |   |      |   |      | G |      |   |      | G |      |   |      |   |      |   |      |   |      |   |      |   |</span><br><span class="line">//      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |</span><br><span class="line">//      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |</span><br><span class="line">//        A          B                                C          D          E          F          G          H          I          J</span><br><span class="line">void pre_order_print_nr(Bin_tree root)    //前序非递归遍历</span><br><span class="line">{</span><br><span class="line">    Stack *stack = init_stack(); </span><br><span class="line">    Tree_node *p_node = NULL;</span><br><span class="line"></span><br><span class="line">    if(root == NULL)</span><br><span class="line">    {</span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p_node = root;</span><br><span class="line">    push_stack(stack, p_node);</span><br><span class="line"></span><br><span class="line">    while(!is_stack_empty(stack))</span><br><span class="line">    {</span><br><span class="line">        get_top_stack(stack, (void **)&p_node);</span><br><span class="line">        printf("%c ", p_node->data);</span><br><span class="line">        pop_stack(stack);</span><br><span class="line"></span><br><span class="line">        if(p_node->right_child != NULL)</span><br><span class="line">        {</span><br><span class="line">            push_stack(stack, p_node->right_child);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if(p_node->left_child != NULL)</span><br><span class="line">        {</span><br><span class="line">            push_stack(stack, p_node->left_child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    destroy_stack(&stack);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//三.5.中序非递归遍历</span><br><span class="line">//void mid_order_print_nr(Bin_tree root);                                     </span><br><span class="line">//                  A</span><br><span class="line">//                /   \</span><br><span class="line">//               B     G   </span><br><span class="line">//              / \    / \</span><br><span class="line">//             C   D  H   J</span><br><span class="line">//                / \  \</span><br><span class="line">//               E   F  I</span><br><span class="line">//</span><br><span class="line">//           CBEDFAHIGJ</span><br><span class="line">//</span><br><span class="line">//         思路：</span><br><span class="line">//</span><br><span class="line">//            1.使用栈进行回溯</span><br><span class="line">//            2.每打印完一个节点，要对其右孩子做处理</span><br><span class="line">//            3.每个节点都需要不断找到最左边的孩子进行打印</span><br><span class="line">//                                                                                                                                  </span><br><span class="line">//                                                                                                                                  </span><br><span class="line">//                           C      B                    E      D             F      A                    H             I      G           J</span><br><span class="line">//    | A |  | B |  | C |  | B |  | A |  | D |  | E |  | D |  | A |  | F |  | A |  |   |  | G |  | H |  | G |  | I |  | G |  |   | | J | |   | </span><br><span class="line">//    |   |  | A |  | B |  | A |  |   |  | A |  | D |  | A |  |   |  | A |  |   |  |   |  |   |  | G |  |   |  | G |  |   |  |   | |   | |   |   </span><br><span class="line">//    |   |  |   |  | A |  |   |  |   |  |   |  | A |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   | |   | |   | </span><br><span class="line">//    |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   | |   | |   | </span><br><span class="line">//    |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   | |   | |   | </span><br><span class="line">//                           C      B                    E      D             F      A                    H             I      G           J</span><br><span class="line">//</span><br><span class="line">void mid_order_print_nr(Bin_tree root)    //中序非递归遍历</span><br><span class="line">{</span><br><span class="line">    Stack *stack = NULL;</span><br><span class="line">    Tree_node *p_node = NULL;</span><br><span class="line"></span><br><span class="line">    if(root == NULL){</span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    stack = init_stack();</span><br><span class="line">    p_node = root;</span><br><span class="line"></span><br><span class="line">    while(!is_stack_empty(stack) || p_node != NULL)</span><br><span class="line">    {</span><br><span class="line">        while(p_node != NULL)</span><br><span class="line">        {  //首先找到当前节点最左边的节点</span><br><span class="line">            push_stack(stack, p_node);</span><br><span class="line">            p_node = p_node->left_child;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        get_top_stack(stack, (void **)&p_node);</span><br><span class="line">        printf("%c ", p_node->data);</span><br><span class="line">        pop_stack(stack);</span><br><span class="line"></span><br><span class="line">        p_node = p_node->right_child;</span><br><span class="line">    }</span><br><span class="line">    destroy_stack(&stack);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//三.6.后序非递归遍历</span><br><span class="line">//void last_order_print_nr(Bin_tree root)                                  </span><br><span class="line">void last_order_print_nr(Bin_tree root)                               </span><br><span class="line">{</span><br><span class="line">    int tag = 0;</span><br><span class="line">    Stack *stack = NULL;</span><br><span class="line">    Tree_node *p_node = NULL;</span><br><span class="line">    Tree_node *q_node = NULL;</span><br><span class="line"></span><br><span class="line">    if(root == NULL){</span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    stack = init_stack();</span><br><span class="line">    p_node = root;</span><br><span class="line"></span><br><span class="line">    do</span><br><span class="line">    {</span><br><span class="line">        while(p_node != NULL)</span><br><span class="line">        {  //首先找到当前节点最左边的节点</span><br><span class="line">            push_stack(stack, p_node);</span><br><span class="line">            p_node = p_node->left_child;</span><br><span class="line">        }</span><br><span class="line">        q_node = NULL;</span><br><span class="line">        tag = 1;</span><br><span class="line">        while(!is_stack_empty(stack) && tag )</span><br><span class="line">        {</span><br><span class="line">            get_top_stack(stack, (void **)&p_node);</span><br><span class="line">            if(p_node -> right_child == q_node)</span><br><span class="line">            {</span><br><span class="line">                printf("%c ", p_node->data);</span><br><span class="line">                pop_stack(stack);</span><br><span class="line">                q_node = p_node;</span><br><span class="line">            }</span><br><span class="line">            else</span><br><span class="line">            {</span><br><span class="line">                tag =0;</span><br><span class="line">                p_node = p_node->right_child;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }while(!is_stack_empty(stack));</span><br><span class="line">    destroy_stack(&stack);</span><br><span class="line">}</span><br><span class="line">//三.7.层序遍历</span><br><span class="line">//void level_order_print(Bin_tree root);                                      </span><br><span class="line">//</span><br><span class="line">//                  A</span><br><span class="line">//                /   \</span><br><span class="line">//               B     G   </span><br><span class="line">//              / \    / \</span><br><span class="line">//             C   D  H   J</span><br><span class="line">//                / \  \</span><br><span class="line">//               E   F  I</span><br><span class="line">//</span><br><span class="line">//         A  B  G  C  D  H  J  E  F  I</span><br><span class="line">//</span><br><span class="line">//   队列进行层序遍历：</span><br><span class="line">//   </span><br><span class="line">//  ^                 A          B                     G          C          D          H          J          E          F          I </span><br><span class="line">//  |    | A |      |   |      | G |      | G |      | C |      | D |      | H |      | J |      | E |      | F |      | I |      |   | </span><br><span class="line">//  ^    |   |      |   |      |   |      | C |      | D |      | H |      | J |      | E |      | F |      | I |      |   |      |   |  </span><br><span class="line">//  |    |   |      |   |      |   |      | D |      | H |      | J |      | E |      | F |      | I |      |   |      |   |      |   |</span><br><span class="line">//  ^    |   |      |   |      |   |      |   |      | J |      |   |      | F |      | I |      |   |      |   |      |   |      |   |</span><br><span class="line">//  |    |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |      |   |</span><br><span class="line">//  ^                 A          B                     G          C          D          H          J          E          F          I </span><br><span class="line">//</span><br><span class="line">void level_order_print(Bin_tree root)    //层序遍历</span><br><span class="line">{</span><br><span class="line">    Queue *queue = NULL;</span><br><span class="line">    Tree_node *p_node = NULL;    </span><br><span class="line"></span><br><span class="line">    if(root == NULL){ </span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    queue = init_queue();</span><br><span class="line">    p_node = root;</span><br><span class="line"></span><br><span class="line">    in_queue(queue, p_node);</span><br><span class="line">    while(!is_queue_empty(queue))</span><br><span class="line">    {</span><br><span class="line">        get_front_queue(queue, (void **)&p_node);</span><br><span class="line">        out_queue(queue);</span><br><span class="line">        printf("%c ", p_node->data);</span><br><span class="line"></span><br><span class="line">        if(p_node->left_child != NULL)</span><br><span class="line">        {</span><br><span class="line">            in_queue(queue, p_node->left_child);</span><br><span class="line">        }</span><br><span class="line">   </span><br><span class="line">        if(p_node->right_child != NULL)</span><br><span class="line">        {</span><br><span class="line">            in_queue(queue, p_node->right_child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    destroy_queue(&queue);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>四．二叉树的变量</strong><br>1.得到二叉树的镜像<br>2.得到二叉树的高度<br>3.得到二叉树的最大路径<br>4.得到二叉树的节点个数<br>5.得到二叉树的叶子节点个数<br>6.得到指定层级的节点个数<br>7.二叉树的拷贝</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//四.二叉树的变量</span></span><br><span class="line"><span class="comment">//四.1.得到二叉树的镜像</span></span><br><span class="line"><span class="comment">//void swap_left_right(Bin_tree root);                                        </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_left_right</span><span class="params">(Bin_tree root)</span>   <span class="comment">//得到二叉树的镜像</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//        A      |      A</span></span><br><span class="line"><span class="comment">//       / \     |     / \</span></span><br><span class="line"><span class="comment">//      B   C    |    C   B</span></span><br><span class="line"><span class="comment">//     / \   \   |   /   / \</span></span><br><span class="line"><span class="comment">//    D   E   F  |  F   E   D</span></span><br><span class="line">   <span class="keyword">if</span>(root == <span class="literal">NULL</span> || (root->left_child == <span class="literal">NULL</span> </span><br><span class="line">                    && root->right_child == <span class="literal">NULL</span>)){</span><br><span class="line">       <span class="keyword">return</span> ;</span><br><span class="line">   }   </span><br><span class="line"></span><br><span class="line">   swap(&(root->left_child), &(root->right_child), <span class="keyword">sizeof</span>(Tree_node *));</span><br><span class="line"></span><br><span class="line">   swap_left_right(root->left_child);</span><br><span class="line">   swap_left_right(root->right_child);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//四.2.得到二叉树的高度</span></span><br><span class="line"><span class="comment">//int get_binarytree_height(Bin_tree root);                                  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_binarytree_height</span><span class="params">(Bin_tree root)</span>    <span class="comment">//得到二叉树的高度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//                  A</span></span><br><span class="line">    <span class="comment">//                /   \</span></span><br><span class="line">    <span class="comment">//               B     G   </span></span><br><span class="line">    <span class="comment">//              / \    / \</span></span><br><span class="line">    <span class="comment">//             C   D  H   J</span></span><br><span class="line">    <span class="comment">//                / \  \</span></span><br><span class="line">    <span class="comment">//               E   F  I</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }    </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(get_binarytree_height(root->left_child),</span><br><span class="line">                   get_binarytree_height(root->right_child));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//四.3.得到二叉树的最大路径</span></span><br><span class="line"><span class="comment">//int get_largest_dir_count(Bin_tree root);                                 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  A                                A                               A</span></span><br><span class="line"><span class="comment">//                /   \                             /                               / \</span></span><br><span class="line"><span class="comment">//               B     G                           B                               B   C</span></span><br><span class="line"><span class="comment">//              / \    / \                        / \                             / \</span></span><br><span class="line"><span class="comment">//             C   D  H   J                      C   D                           D   E</span></span><br><span class="line"><span class="comment">//                / \  \                        /     \                         /     \</span></span><br><span class="line"><span class="comment">//               E   F  I                      E       F                       F       G</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//          最大路径：</span></span><br><span class="line"><span class="comment">//               EDBAGHI                         ECBDF                            FDBAC</span></span><br><span class="line"><span class="comment">//               长度为6　　　　　　　　　　　　长度为4　　　　　　　　　　　　　　长度为4</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//          情况A：路径经过左子树的最深节点，通过根节点，再到右子树的最深节点；</span></span><br><span class="line"><span class="comment">//          情况B：路径不穿过根节点，而是左子树(或右子树)的最大距离路径，取其大者．</span></span><br><span class="line"><span class="comment">//         </span></span><br><span class="line"><span class="comment">//          这两种情况的最大值就是该二叉树的最大路径．</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_largest_dir_count</span><span class="params">(Bin_tree root)</span>                                   </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> distence = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root->left_child == <span class="literal">NULL</span> && root->right_child == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    distence = <span class="built_in">max</span>(get_binarytree_height(root->left_child)+get_binarytree_height(root->right_child),</span><br><span class="line">                   <span class="built_in">max</span>(get_largest_dir_count(root->left_child), get_largest_dir_count(root->right_child)));</span><br><span class="line">    <span class="keyword">return</span> distence;   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//四.4.得到二叉树的节点个数</span></span><br><span class="line"><span class="comment">//int get_binarytree_node_count(Bin_tree root);                               </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_binarytree_node_count</span><span class="params">(Bin_tree root)</span>   <span class="comment">//得到二叉树的节点个数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//1 + 左（右）子树节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + get_binarytree_node_count(root->left_child)</span><br><span class="line">             + get_binarytree_node_count(root->right_child);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//四.5.得到二叉树的叶子节点个数</span></span><br><span class="line"><span class="comment">//int get_binarytree_leaf_count(Bin_tree root);                               </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_binarytree_leaf_count</span><span class="params">(Bin_tree root)</span>    <span class="comment">//得到二叉树的叶子节点个数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//root->left_child == NULL && root->right_child == NULL</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root->left_child == <span class="literal">NULL</span> && root->right_child == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> get_binarytree_leaf_count(root->left_child)</span><br><span class="line">             + get_binarytree_leaf_count(root->right_child);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//四.6.得到指定层级的节点个数</span></span><br><span class="line"><span class="comment">//int get_binarytree_level_count(Bin_tree root, int level);                  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_binarytree_level_count</span><span class="params">(Bin_tree root, <span class="keyword">int</span> level)</span>    <span class="comment">//得到指定层级的节点个数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//                  A</span></span><br><span class="line">    <span class="comment">//                /   \</span></span><br><span class="line">    <span class="comment">//               B     G   </span></span><br><span class="line">    <span class="comment">//              / \    / \</span></span><br><span class="line">    <span class="comment">//             C   D  H   J</span></span><br><span class="line">    <span class="comment">//                / \  \</span></span><br><span class="line">    <span class="comment">//               E   F  I</span></span><br><span class="line">    <span class="keyword">int</span> num_left =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num_right = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || level < ONE || level > get_binarytree_height(root))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    } </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(level == ONE)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    num_left = get_binarytree_level_count(root->left_child, level - <span class="number">1</span>); </span><br><span class="line">    num_right = get_binarytree_level_count(root->right_child, level - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num_left + num_right;    </span><br><span class="line">}</span><br><span class="line"><span class="comment">//四.7.二叉树的拷贝</span></span><br><span class="line"><span class="comment">//Bin_tree copy_binary_tree(Bin_tree root);                                  </span></span><br><span class="line"><span class="function">Bin_tree <span class="title">copy_binary_tree</span><span class="params">(Bin_tree root)</span>    <span class="comment">//二叉树的拷贝</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">    Bin_tree result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1.如果当前节点存在，则构建当前节点，</span></span><br><span class="line">    <span class="comment">//然后递归地创建当前节点地左右子树部分</span></span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        result = create_node();</span><br><span class="line">        result->data = root->data;</span><br><span class="line">        result->left_child = copy_binary_tree(root->left_child);</span><br><span class="line">        result->right_child = copy_binary_tree(root->right_child);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>五.二叉树的性质</strong><br>1.判断是否是满二叉树<br>2.判断是否是完全二叉树<br>3.判断是否是平衡二叉树<br>4.判断二叉树是否包含<br>5.判断二叉树是否相等</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//五.二叉树的性质</span></span><br><span class="line"><span class="comment">//五.1.判断是否是满二叉树</span></span><br><span class="line"><span class="comment">//Boolean is_full_binary_tree(Bin_tree root);                                </span></span><br><span class="line"><span class="function">Boolean <span class="title">is_full_binary_tree</span><span class="params">(Bin_tree root)</span>   <span class="comment">//判断是否是满二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>){</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到二叉树的高度h和节点个数n</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//判断:</span></span><br><span class="line">    <span class="comment">//    if (2^h - 1) == n,  满二叉树</span></span><br><span class="line">    <span class="comment">//    else   不是满二叉树</span></span><br><span class="line">    <span class="built_in">height</span> = get_binarytree_height(root);</span><br><span class="line">    count = get_binarytree_node_count(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  ( ((<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, <span class="built_in">height</span>) - <span class="number">1</span>) == count) ;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//五.2.判断是否是完全二叉树</span></span><br><span class="line"><span class="comment">//Boolean is_complete_binary_tree(Bin_tree root);                            </span></span><br><span class="line"><span class="comment">//                  A</span></span><br><span class="line"><span class="comment">//                /   \</span></span><br><span class="line"><span class="comment">//               B     G   </span></span><br><span class="line"><span class="comment">//              / \    / </span></span><br><span class="line"><span class="comment">//             C   D  H   </span></span><br><span class="line"><span class="comment">//                                                       </span></span><br><span class="line"><span class="comment">//     1.层序遍历:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     2.分两个状态：</span></span><br><span class="line"><span class="comment">//                    从根节点开始，入队列，如果队列不为空，循环。</span></span><br><span class="line"><span class="comment">//                    遇到第一个没有左儿子或者右儿子的节点，设置标志位，</span></span><br><span class="line"><span class="comment">//                    如果之后再遇到有左/右儿子的节点，那么这不是一颗完全二叉树。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                  A           </span></span><br><span class="line"><span class="comment">//                /   \</span></span><br><span class="line"><span class="comment">//               B     G        </span></span><br><span class="line"><span class="comment">//              / \   / \</span></span><br><span class="line"><span class="comment">//             C   D H   J     </span></span><br><span class="line"><span class="comment">//            / \ / \</span></span><br><span class="line"><span class="comment">//           K  L E  F  </span></span><br><span class="line"><span class="function">Boolean <span class="title">is_complete_binary_tree</span><span class="params">(Bin_tree root)</span>   <span class="comment">//判断是否是完全二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    Queue *<span class="built_in">queue</span> = <span class="literal">NULL</span>;</span><br><span class="line">    Tree_node *p_node = <span class="literal">NULL</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>){ </span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> = init_queue();</span><br><span class="line">    p_node = root;</span><br><span class="line"></span><br><span class="line">    in_queue(<span class="built_in">queue</span>, p_node);</span><br><span class="line">    <span class="keyword">while</span>(!is_queue_empty(<span class="built_in">queue</span>))</span><br><span class="line">    {</span><br><span class="line">        get_front_queue(<span class="built_in">queue</span>, (<span class="keyword">void</span> **)&p_node);</span><br><span class="line">        out_queue(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="comment">//printf("%c ", p_node->data);</span></span><br><span class="line">        <span class="keyword">if</span>(p_node->left_child == <span class="literal">NULL</span> || p_node->right_child == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(p_node->left_child != <span class="literal">NULL</span> || p_node->right_child != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//printf("not complete \n");</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(p_node->left_child != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            in_queue(<span class="built_in">queue</span>, p_node->left_child);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(p_node->right_child != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            in_queue(<span class="built_in">queue</span>, p_node->right_child);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//printf("complete\n");</span></span><br><span class="line">    destroy_queue(&<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//五.3.判断是否是平衡二叉树</span></span><br><span class="line"><span class="comment">//Boolean is_balance_binary_tree(Bin_tree root);                            </span></span><br><span class="line"><span class="comment">//1.平衡条件：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   左右子树高度差小于等于1，左右子树内部也要平衡</span></span><br><span class="line"><span class="function">Boolean <span class="title">is_balance_binary_tree</span><span class="params">(Bin_tree root)</span>     <span class="comment">//判断是否是平衡二叉树</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> left_height = get_binarytree_height(root->left_child);</span><br><span class="line">    <span class="keyword">int</span> right_height = get_binarytree_height(root->right_child);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(left_height - right_height) > <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> is_balance_binary_tree(root->left_child) && is_balance_binary_tree(root->right_child);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//五.4.判断二叉树是否包含</span></span><br><span class="line"><span class="comment">//Boolean is_include_tree(Bin_tree root1, Bin_tree root2);  </span></span><br><span class="line"><span class="comment">//                  A</span></span><br><span class="line"><span class="comment">//                /   \</span></span><br><span class="line"><span class="comment">//               B     G   </span></span><br><span class="line"><span class="comment">//              / \    / \</span></span><br><span class="line"><span class="comment">//             C   D  H   J</span></span><br><span class="line"><span class="comment">//                / \  \</span></span><br><span class="line"><span class="comment">//               E   F  I</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//               B</span></span><br><span class="line"><span class="comment">//              / \</span></span><br><span class="line"><span class="comment">//             C   D</span></span><br><span class="line"><span class="comment">//        1.找root2在root1中的位置，如果存在，则在root1对于</span></span><br><span class="line"><span class="comment">//        的位置开始（p_node），递归地对root2的左右子树部分进行</span></span><br><span class="line"><span class="comment">//        查找，如果root2遍历结束，则认为root2包含于root1</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Boolean <span class="title">is_include_tree</span><span class="params">(Bin_tree root1,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Bin_tree root2)</span>    <span class="comment">//二叉树是否包含</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }</span><br><span class="line">    Tree_node *p_node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((p_node = find_value(root1, root2->data)) == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (is_include_tree(p_node, root2->left_child) && is_include_tree(p_node, root2->right_child));</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//五.5.判断二叉树是否相等</span></span><br><span class="line"><span class="comment">//Boolean is_binarytree_equal(Bin_tree root1, Bin_tree root2);          </span></span><br><span class="line"><span class="function">Boolean <span class="title">is_binarytree_equal</span><span class="params">(Bin_tree root1,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Bin_tree root2)</span>    <span class="comment">//二叉树是否相等</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//1.相等：</span></span><br><span class="line">    <span class="comment">//（1）root1和root2都为NULL,相等</span></span><br><span class="line">    <span class="comment">//（2）root1和root2都存在，并且data相等，并且左（右）子树部分都相等</span></span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> && root2 == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (root1 != <span class="literal">NULL</span> && root2 != <span class="literal">NULL</span>) </span><br><span class="line">              && root1->data == root2->data</span><br><span class="line">              && is_binarytree_equal(root1->left_child, root2->left_child)</span><br><span class="line">              && is_binarytree_equal(root1->right_child, root2->right_child)   )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<p><strong>六.二叉树的查找</strong><br>1.找到指定值所在的节点<br>2.找到指定节点的双亲节点<br>3.找到两个节点的最近公共节点</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//六.二叉树的查找</span></span><br><span class="line"><span class="comment">//六.1.找到指定值所在的节点</span></span><br><span class="line"><span class="comment">//Tree_node *find_value(Bin_tree root, char value);                          </span></span><br><span class="line"><span class="function">Tree_node *<span class="title">find_value</span><span class="params">(Bin_tree root, <span class="keyword">char</span> value)</span>    <span class="comment">//找到指定值所在的节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *p_node = <span class="literal">NULL</span>;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || root->data == value)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }     </span><br><span class="line">  </span><br><span class="line">    p_node = find_value(root->left_child, value);</span><br><span class="line">    <span class="keyword">if</span>(p_node == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        p_node = find_value(root->right_child, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p_node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//六.2.找到指定节点的双亲节点</span></span><br><span class="line"><span class="comment">//Tree_node *find_parent(Bin_tree root, Tree_node *node);</span></span><br><span class="line"><span class="function">Tree_node *<span class="title">find_parent</span><span class="params">(Bin_tree root,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Tree_node *node)</span>    <span class="comment">//找到指定节点的双亲节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Tree_node *p_node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> || root->left_child == node </span><br><span class="line">                    || root->right_child == node){</span><br><span class="line">        <span class="comment">//root不存在或者root是所要找的双亲节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    p_node = find_parent(root->left_child, node); </span><br><span class="line">    <span class="keyword">if</span>(p_node == <span class="literal">NULL</span>){ </span><br><span class="line">        p_node = find_parent(root->right_child, node);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p_node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//六.3.找到两个节点的最近公共节点</span></span><br><span class="line"><span class="comment">//Tree_node *find_common_node(Bin_tree root, Tree_node *node1, Tree_node *node2 );                  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Tree_node *<span class="title">find_common</span><span class="params">(Bin_tree root,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Tree_node *node1, Tree_node *node2)</span></span>{</span><br><span class="line">    <span class="comment">// 从根节点开始：</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果node1和node2分别在root左右子树部分，则root为最近公共祖先；</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果在左（右），则对root的左（右）子树部分进行递归的处理，直到满足</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// node1 和node2在不同侧的情况</span></span><br><span class="line">    <span class="keyword">if</span>(find_value(root->left_child, node1->data))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(find_value(root->right_child, node2->data))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        { </span><br><span class="line">            <span class="keyword">return</span> find_common(root->left_child, node1, node2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(find_value(root->left_child, node2->data))</span><br><span class="line">        { </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        { </span><br><span class="line">            <span class="keyword">return</span> find_common(root->right_child, node1, node2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Tree_node *<span class="title">find_common_node</span><span class="params">(Bin_tree root, Tree_node *node1,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Tree_node *node2 )</span>   <span class="comment">//找到两个节点的最近公共节点</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//                  A</span></span><br><span class="line">    <span class="comment">//                /   \</span></span><br><span class="line">    <span class="comment">//               B     G   </span></span><br><span class="line">    <span class="comment">//              / \    / \</span></span><br><span class="line">    <span class="comment">//             C   D  H   J</span></span><br><span class="line">    <span class="comment">//                / \  \</span></span><br><span class="line">    <span class="comment">//               E   F  I</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//  1.如果出现node1和node2有继承关系，则返回高度较高节点的双亲节点</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    find_value</span></span><br><span class="line">    <span class="comment">//    find_parent</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> height1 = get_binarytree_height(node1);</span><br><span class="line">    <span class="keyword">int</span> height2 = get_binarytree_height(node2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理包含关系</span></span><br><span class="line">    <span class="keyword">if</span>(height1 > height2)</span><br><span class="line">    {   </span><br><span class="line">        <span class="keyword">if</span>(find_value(node1, node2->data) != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> find_parent(root, node1);         </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(height1 < height2)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(find_value(node2, node1->data) != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> find_parent(root, node2);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//处理非包含关系</span></span><br><span class="line">    <span class="keyword">return</span> find_common(root, node1, node2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="七．功能检测"><a href="#七．功能检测" class="headerlink" title="七．功能检测"></a>七．功能检测</h2><ul>
<li><code>main.c</code></li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></stdio.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"binary_tree.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Bin_tree root = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root1 = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root2 = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root3 = <span class="literal">NULL</span>;</span><br><span class="line">    Bin_tree root4 = <span class="literal">NULL</span>;</span><br><span class="line">    Tree_node *<span class="built_in">find</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"ABC##DE##F##GH#I##J##"</span>;</span><br><span class="line">    <span class="keyword">char</span> *pre  = <span class="string">"ABCDEFGHIJ"</span>;</span><br><span class="line">    <span class="keyword">char</span> *mid  = <span class="string">"CBEDFAHIGJ"</span>;</span><br><span class="line">    <span class="keyword">char</span> *last = <span class="string">"CEFDBIHJGA"</span>;</span><br><span class="line">    <span class="comment">////////1</span></span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"ABCK##L##DE##F##GH##J##"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str4 = <span class="string">"BC##D##"</span>;</span><br><span class="line">    Boolean equal = FALSE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"一.1.创建二叉树\n"</span>);</span><br><span class="line"></span><br><span class="line">    root = create_tree(&str);    <span class="comment">//二叉树的创建</span></span><br><span class="line">    root1 = create_tree(&str1);</span><br><span class="line">    root2 = create_tree_by_pre_mid(pre, mid, <span class="built_in">strlen</span>(pre));</span><br><span class="line">    root4 = create_tree(&str4);</span><br><span class="line">    <span class="comment">//root1 = create_tree_by_mid_last(mid, last, strlen(pre));</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     root,root2:                root1:          root4:       \n"</span>);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                  A                   A                      \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                /   \\               /   \\                  \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               B     G             B     G           B       \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"              / \\    / \\          / \\   / \\         / \\ \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"             C   D  H   J        C   D  H   J      C   D     \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                / \\  \\          /\\  /\\                   \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               E   F  I        K  L E F                      \n"</span>);            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"二.遍历二叉树：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pre order root:\n"</span>);</span><br><span class="line">    pre_order_print(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pre order nr root:\n"</span>);</span><br><span class="line">    pre_order_print_nr(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order root:\n"</span>);</span><br><span class="line">    mid_order_print(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order nr root:\n"</span>);</span><br><span class="line">    mid_order_print_nr(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"last order root:\n"</span>);</span><br><span class="line">    last_order_print(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"last order nr root:\n"</span>);</span><br><span class="line">    last_order_print_nr(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"last order root1:\n"</span>);</span><br><span class="line">    last_order_print(root1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"last order nr root1:\n"</span>);</span><br><span class="line">    last_order_print_nr(root1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"level order root1:\n"</span>);</span><br><span class="line">    level_order_print(root1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"三.二叉树的变量:\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order root :\n"</span>);</span><br><span class="line">    mid_order_print(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order coped root2:\n"</span>);</span><br><span class="line">    mid_order_print_nr(root2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//得到二叉树高度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the height of root2:%d\n"</span>, get_binarytree_height(root2));</span><br><span class="line">    <span class="comment">//得到二叉树节点个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the count of root2:%d\n"</span>, get_binarytree_node_count(root2));</span><br><span class="line">    <span class="comment">//得到二叉树叶子节点个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the leaves count of root2:%d\n"</span>, get_binarytree_leaf_count(root2));</span><br><span class="line">    <span class="comment">//得到二叉树的最大路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the largest dir count of root2:%d\n"</span>, get_largest_dir_count(root2));</span><br><span class="line">    <span class="comment">//得到第n层二叉树的节点个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the %d level count is:%d\n"</span>, <span class="number">3</span>, get_binarytree_level_count(root, <span class="number">3</span>));</span><br><span class="line">    <span class="comment">//得到二叉树镜像</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pre order root2:\n"</span>);</span><br><span class="line">    pre_order_print_nr(root2);</span><br><span class="line">    swap_left_right(root2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nswap pre order root2:\n"</span>);</span><br><span class="line">    pre_order_print_nr(root2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">//二叉树的拷贝 </span></span><br><span class="line">    root3 = copy_binary_tree(root1);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"root3 = copy_binary_tree(root1)\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order root1 :\n"</span>);</span><br><span class="line">    mid_order_print(root1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order root3 :\n"</span>);</span><br><span class="line">    mid_order_print(root3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"四.二叉树的性质：\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     root,                    root2:              root1,root3:    root4:            \n"</span>);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                  A         |       A                  A                            \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                /   \\       |     /   \\              /   \\                       \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               B     G      |    G     B            B     G           B             \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"              / \\    / \\    |   / \\    / \\         / \\   / \\         / \\     \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"             C   D  H   J   |  J   H  D   C       C   D  H   J      C   D           \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"                / \\  \\      |     /  / \\         /\\  /\\                        \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"               E   F  I     |    I   F  E       K  L E F                            \n"</span>);            </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是满二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(is_full_binary_tree(root1) == TRUE){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root1 is full!\n"</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root1 is not full!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//判断是否完全二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(is_complete_binary_tree(root1) == TRUE){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root1 is complete!\n"</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root1 is not complete!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//判断是否平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(is_balance_binary_tree(root1) == TRUE){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root1 is balance!\n"</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root1 is not balance!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//判断二叉树是否包含</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order root  :\n"</span>);</span><br><span class="line">    mid_order_print(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order root4 :\n"</span>);</span><br><span class="line">    mid_order_print(root4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(is_include_tree(root, root4) == TRUE){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root4 is include root!\n"</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root1 is not include!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//判断二叉树是否相等</span></span><br><span class="line">    <span class="keyword">if</span>((equal = is_binarytree_equal(root1, root3)) == TRUE)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"root1 root3 two trees are equal!\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"五.二叉树的查找\n"</span>);</span><br><span class="line">    <span class="comment">//找到值所在节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mid order root  :\n"</span>);</span><br><span class="line">    mid_order_print(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">find</span> = find_value(root, <span class="string">'H'</span>)) == <span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"H is not found!\n"</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c is found!\n"</span>, <span class="built_in">find</span>->data);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    Tree_node *find1 = find_value(root, <span class="string">'B'</span>);</span><br><span class="line">    Tree_node *find2 = find_value(root, <span class="string">'I'</span>);</span><br><span class="line">    <span class="comment">//找到两个节点的最近公共祖先</span></span><br><span class="line">    Tree_node *parent = find_common_node(root, find1, find2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(parent != <span class="literal">NULL</span>){ </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%c and %c) parent is:%c\n"</span>,</span><br><span class="line">            find1->data, find2->data, parent->data);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not have parent!\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n**********************************************************************************\n"</span>);</span><br><span class="line">    destroy_tree_nr(&root);</span><br><span class="line">    destroy_tree_nr(&root1);</span><br><span class="line">    destroy_tree_nr(&root2);</span><br><span class="line">    destroy_tree_nr(&root3);</span><br><span class="line">    destroy_tree_nr(&root4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<ul>
<li>运行结果：</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@aemonair:~binary_tree<span class="meta"># cc.sh  *.c</span></span><br><span class="line">Compiling ...</span><br><span class="line">-e CC      binary_tree.c dlist.c main.c <span class="built_in">queue</span>.c <span class="built_in">stack</span>.c tools.c -g -lpthread -lm</span><br><span class="line">-e         Completed .</span><br><span class="line">-e         Thu Aug  <span class="number">4</span> <span class="number">23</span>:<span class="number">52</span>:<span class="number">07</span> CST <span class="number">2016</span></span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">root@aemonair:~/binary_tree# ./binary_tree</span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br><span class="line">一<span class="number">.1</span>.创建二叉树</span><br><span class="line">     root,root2:                root1:          root4:       </span><br><span class="line">                  A                   A                      </span><br><span class="line">                /   \               /   \                  </span><br><span class="line">               B     G             B     G           B       </span><br><span class="line">              / \    / \          / \   / \         / \ </span><br><span class="line">             C   D  H   J        C   D  H   J      C   D     </span><br><span class="line">                / \  \          /\  /\                   </span><br><span class="line">               E   F  I        K  L E F                      </span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br><span class="line">二.遍历二叉树：</span><br><span class="line">pre order root:</span><br><span class="line">A B C D E F G H I J </span><br><span class="line">pre order nr root:</span><br><span class="line">A B C D E F G H I J </span><br><span class="line">mid order root:</span><br><span class="line">C B E D F A H I G J </span><br><span class="line">mid order nr root:</span><br><span class="line">C B E D F A H I G J </span><br><span class="line">last order root:</span><br><span class="line">C E F D B I H J G A </span><br><span class="line">last order nr root:</span><br><span class="line">C E F D B I H J G A </span><br><span class="line">last order root1:</span><br><span class="line">K L C E F D B H J G A </span><br><span class="line">last order nr root1:</span><br><span class="line">K L C E F D B H J G A </span><br><span class="line">level order root1:</span><br><span class="line">A B G C D H J K L E F </span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br><span class="line">三.二叉树的变量:</span><br><span class="line">mid order root :</span><br><span class="line">C B E D F A H I G J </span><br><span class="line">mid order coped root2:</span><br><span class="line">C B E D F A H I G J </span><br><span class="line">the <span class="built_in">height</span> of root2:<span class="number">4</span></span><br><span class="line">the count of root2:<span class="number">10</span></span><br><span class="line">the leaves count of root2:<span class="number">5</span></span><br><span class="line">the largest dir count of root2:<span class="number">6</span></span><br><span class="line">the <span class="number">3</span> level count is:<span class="number">4</span></span><br><span class="line">pre order root2:</span><br><span class="line">A B C D E F G H I J </span><br><span class="line">swap pre order root2:</span><br><span class="line">A G J H I B D F E C </span><br><span class="line">root3 = copy_binary_tree(root1)</span><br><span class="line">mid order root1 :</span><br><span class="line">K C L B E D F A H G J </span><br><span class="line">mid order root3 :</span><br><span class="line">K C L B E D F A H G J </span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br><span class="line">四.二叉树的性质：</span><br><span class="line">     root,                    root2:              root1,root3:    root4:            </span><br><span class="line">                  A         |       A                  A                            </span><br><span class="line">                /   \       |     /   \              /   \                       </span><br><span class="line">               B     G      |    G     B            B     G           B             </span><br><span class="line">              / \    / \    |   / \    / \         / \   / \         / \     </span><br><span class="line">             C   D  H   J   |  J   H  D   C       C   D  H   J      C   D           </span><br><span class="line">                / \  \      |     /  / \         /\  /\                        </span><br><span class="line">               E   F  I     |    I   F  E       K  L E F                            </span><br><span class="line">root1 is <span class="keyword">not</span> full!</span><br><span class="line">root1 is complete!</span><br><span class="line">root1 is balance!</span><br><span class="line">mid order root  :</span><br><span class="line">C B E D F A H I G J </span><br><span class="line">mid order root4 :</span><br><span class="line">C B D </span><br><span class="line">root4 is include root!</span><br><span class="line">root1 root3 two trees are equal!</span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br><span class="line">五.二叉树的查找</span><br><span class="line">mid order root  :</span><br><span class="line">C B E D F A H I G J </span><br><span class="line">H is found!</span><br><span class="line">(B <span class="keyword">and</span> I) parent is:A</span><br><span class="line"></span><br><span class="line">**********************************************************************************</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>　　　嗯…然后呢…<br>　　　上次说树，是数据结构中非常重要的非线性结构．<br>　　　我们总算是对二叉树的各种操作做了这么多详细研究，呼～<br>　　　创建二叉树可以通过字符串创建，可以通过前序中序，或者中序后序创建．<br>      二叉树的类型，像满二叉树，平衡二叉树这样的类型判断可以用到性质，通过节点高度等验证得到．<br>　　　嗯～还有，在二叉树里用到了大量递归的概念～好好想想，觉得，嗯，二叉树作为一个重要的数据结构类型，很重要～<br>　　　我们还可以看，在非遍历的过程中，我们对节点要进行各种前后操作，于是用到了栈，用到了队列，还好以前实现过，这里就直接用啦，对不对．<br>　　　<br>　　　Ｈｅｙ　～</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:v.aemonair@gmail.com">Air</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aemonair.github.io/2016/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8411-%E4%BA%8C%E5%8F%89%E6%A0%91/">http://aemonair.github.io/2016/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8411-%E4%BA%8C%E5%8F%89%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Aemonair.github.io">Aemonair</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStruct/">DataStruct    </a><a class="post-meta__tags" href="/tags/Tree/">Tree    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2016/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8412-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>数据结构12.线索二叉树</span></div></a></div><div class="next-post pull_right"><a href="/2016/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8410-%E6%A0%91/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>数据结构10.树</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2016/07/31/数据结构10-树/" title="数据结构10.树"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-07-31</div><div class="relatedPosts_title">数据结构10.树</div></div></a></div><div class="relatedPosts_item"><a href="/2016/08/10/数据结构12-线索二叉树/" title="数据结构12.线索二叉树"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-08-10</div><div class="relatedPosts_title">数据结构12.线索二叉树</div></div></a></div><div class="relatedPosts_item"><a href="/2016/08/26/数据结构14-自平衡二叉查找树-AVL树/" title="数据结构14.自平衡二叉查找树_AVL树"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-08-26</div><div class="relatedPosts_title">数据结构14.自平衡二叉查找树_AVL树</div></div></a></div><div class="relatedPosts_item"><a href="/2016/08/20/数据结构13-二叉搜索树-BST/" title="数据结构13.二叉搜索树_BST"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-08-20</div><div class="relatedPosts_title">数据结构13.二叉搜索树_BST</div></div></a></div><div class="relatedPosts_item"><a href="/2016/07/24/Sort_2_QuickSort/" title="排序_2.快速排序"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-07-24</div><div class="relatedPosts_title">排序_2.快速排序</div></div></a></div><div class="relatedPosts_item"><a href="/2016/07/28/Sort_4_ShellSort/" title="排序_4.希尔排序"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-07-28</div><div class="relatedPosts_title">排序_4.希尔排序</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Air</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">4th ~</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script></body></html>