<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构C语言实现2.带控制信息的链表 | Aemonair</title><meta name="description" content="引言在上一篇博客数据结构1.单链表中，我们对链表相对数组的优缺点进行了比较。而且，我们发现，链表是一种物理存储单元上非连续、非顺序的存储结构，所以，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。若是想要对链表中的其中一个元素进行操作，通常都需要p_node &#x3D; p_node-&gt;next;的循环进行。    计算机科学领域的任何问题，都可以通过增加一个间接中间层来解决。Any probl"><meta name="keywords" content="DataStruct,LinkedList"><meta name="author" content="Air,v.aemonair@gmail.com"><meta name="copyright" content="Air"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/favicon.air.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://www.google-analytics.com"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="http://ta.qq.com"/><link rel="dns-prefetch" href="http://ta.qq.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构C语言实现2.带控制信息的链表"><meta name="twitter:description" content="引言在上一篇博客数据结构1.单链表中，我们对链表相对数组的优缺点进行了比较。而且，我们发现，链表是一种物理存储单元上非连续、非顺序的存储结构，所以，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。若是想要对链表中的其中一个元素进行操作，通常都需要p_node &#x3D; p_node-&gt;next;的循环进行。    计算机科学领域的任何问题，都可以通过增加一个间接中间层来解决。Any probl"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429114508linked-list-car.png"><meta property="og:type" content="article"><meta property="og:title" content="数据结构C语言实现2.带控制信息的链表"><meta property="og:url" content="http://aemonair.github.io/2016/05/31/Data_Structure_02_Single_Linked_List_With_Control/"><meta property="og:site_name" content="Aemonair"><meta property="og:description" content="引言在上一篇博客数据结构1.单链表中，我们对链表相对数组的优缺点进行了比较。而且，我们发现，链表是一种物理存储单元上非连续、非顺序的存储结构，所以，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。若是想要对链表中的其中一个元素进行操作，通常都需要p_node &#x3D; p_node-&gt;next;的循环进行。    计算机科学领域的任何问题，都可以通过增加一个间接中间层来解决。Any probl"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429114508linked-list-car.png"><meta property="article:published_time" content="2016-05-31T15:19:59.000Z"><meta property="article:modified_time" content="2020-04-29T03:45:43.633Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://aemonair.github.io/2016/05/31/Data_Structure_02_Single_Linked_List_With_Control/"><link rel="prev" title="数据结构C语言实现3.双端链表" href="http://aemonair.github.io/2016/06/03/Data_Structure_03_Double_Linked_List/"><link rel="next" title="数据结构C语言实现1.单链表" href="http://aemonair.github.io/2016/05/31/Data_Structure_01_Single_Linked_List/"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-1895967914385994',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?05af6f3318bdeb655af3eaa698a89a71";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-160152781-1', 'auto');
ga('send', 'pageview');
</script><script src="https://tajs.qq.com/stats?sId=66528155" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.air.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#本文的所有源程序可以在single-control-list上得到。"><span class="toc-number">1.1.</span> <span class="toc-text">** 本文的所有源程序可以在single_control_list上得到。**</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一、链表数据类型的定义"><span class="toc-number">2.</span> <span class="toc-text">一、链表数据类型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、链表的接口："><span class="toc-number">3.</span> <span class="toc-text">二、链表的接口：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、链表接口的实现"><span class="toc-number">4.</span> <span class="toc-text">三、链表接口的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、测试功能"><span class="toc-number">5.</span> <span class="toc-text">四、测试功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/2020042911412145-cartoons-of-trains-train-clipart.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Aemonair</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">数据结构C语言实现2.带控制信息的链表</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2016-05-31 23:19:59"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2016-05-31</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-29 11:45:43"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Study/">Study</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h3><p>在上一篇博客<a href="http://blog.csdn.net/aemonair/article/details/51518059" target="_blank" rel="noopener">数据结构1.单链表</a>中，我们对链表相对数组的优缺点进行了比较。<br>而且，我们发现，链表是一种物理存储单元上非连续、非顺序的存储结构，所以，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<br>若是想要对链表中的其中一个元素进行操作，通常都需要<code>p_node = p_node-&gt;next;</code>的循环进行。  </p>
<blockquote>
<p>计算机科学领域的任何问题，都可以通过增加一个间接中间层来解决。<br>Any problems in computer science can be soved by another layer of indirection.  </p>
</blockquote>
<p>   所以，我们在定义这个链表的时候，可以给链表加上一层控制信息。如下：</p>
<h4 id="本文的所有源程序可以在single-control-list上得到。"><a href="#本文的所有源程序可以在single-control-list上得到。" class="headerlink" title="** 本文的所有源程序可以在single_control_list上得到。**"></a>** 本文的所有源程序可以在<a href="https://github.com/aemonair/Data_Struct/tree/master/single_control_list" target="_blank" rel="noopener">single_control_list</a>上得到。**</h4><h3 id="一、链表数据类型的定义"><a href="#一、链表数据类型的定义" class="headerlink" title="一、链表数据类型的定义"></a><strong>一、链表数据类型的定义</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;*链表数据类型定义*&#x2F;<br><br>struct List_node;    &#x2F;&#x2F;声明一个类型<br><br>&#x2F;&#x2F;链表控制信息<br>typedef struct List<br>&#123;<br>    struct List_node *head;    &#x2F;&#x2F;指向链表头部<br>    struct List_node *tail;    &#x2F;&#x2F;指向链表尾部<br>    int              count;    &#x2F;&#x2F;链表节点数量<br>&#125;List;<br><br>&#x2F;&#x2F;链表节点信息<br>typedef struct List_node<br>&#123;<br>    int               data;    &#x2F;&#x2F;数据域<br>    struct List_node *next;    &#x2F;&#x2F;指针域<br>&#125;List_node;<br></code></pre></td></tr></table></figure>

<p>这样我们可以看到，已经可以直接获取到链表节点个数以及指向尾部节点的指针。我们可以用来做什么呢？</p>
<h3 id="二、链表的接口："><a href="#二、链表的接口：" class="headerlink" title="二、链表的接口："></a><strong>二、链表的接口：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;********链表的接口********&#x2F;<br><br>List      *init_list(void)                                 ;    &#x2F;&#x2F;1.  链表的初始化<br>void      destroy_list(List **list)                        ;    &#x2F;&#x2F;2.  链表的销毁<br>Boolean   push_front(List *list, int value)                ;    &#x2F;&#x2F;3.1 头部插入<br>Boolean   push_back(List  *list, int value)                ;    &#x2F;&#x2F;3.2 尾部插入<br>Boolean   pop_front(List *list)                            ;    &#x2F;&#x2F;4.1 头部删除<br>Boolean   pop_back(List *list)                             ;    &#x2F;&#x2F;4.2 尾部删除<br>List_node *find_node(List *list, int value)                ;    &#x2F;&#x2F;5.1 链表的查找<br>List_node *find_revise_node(List *list, int num)           ;    &#x2F;&#x2F;5.2 找到链表的倒数第num个节点<br>List_node *find_mid_node(List *list)                       ;    &#x2F;&#x2F;5.3 找到链表的中间节点<br>void      modify_node(List *list, int value)               ;    &#x2F;&#x2F;6.1 链表节点的修改<br>Boolean   insert_node(List *list, int index, int value)    ;    &#x2F;&#x2F;6.2 链表节点的插入(下标)<br>void      delete_one_node(List *list, List_node *node)     ;    &#x2F;&#x2F;6.3 在O（1）的时间复杂度删除节点<br>void      sort_list_ascend(List *list)                     ;    &#x2F;&#x2F;7.1 升序<br>void      sort_list_descent(List *list)                    ;    &#x2F;&#x2F;7.2 降序排列<br>void      show_list(List *list)                            ;    &#x2F;&#x2F;8.1 显示链表信息<br>void      reverse_show_list(List *list)                    ;    &#x2F;&#x2F;8.2 逆序输出链表信息<br>int       get_list_count(List *list)                       ;    &#x2F;&#x2F;9.  得到链表节点数量<br>List      *merge_two_lists(List *list1, List *list2)       ;    &#x2F;&#x2F;10.  合并两个有序链表<br>List      *merge_two_lists_recure(List *list1, List *list2);    &#x2F;&#x2F;11.  合并两个有序链表（递归）<br>List      *reverse_list(List *list)                        ;    &#x2F;&#x2F;12.  逆置一个链表<br>List      *list_dump(List *list)                           ;    &#x2F;&#x2F;13.  链表的拷贝<br>Boolean   is_list_intersect(List *list1, List *list2)      ;    &#x2F;&#x2F;14.  判断链表是否有交点<br>List_node *get_first_common_node(List *list1, List *list2) ;    &#x2F;&#x2F;15.  得到第一个交点<br>Boolean   has_circle(List *list)                           ;    &#x2F;&#x2F;16.  判断一个链表是否有环<br>List_node *find_circle_first_node(List *list)              ;    &#x2F;&#x2F;17.  找到带环链表的环入口节点<br></code></pre></td></tr></table></figure>

<p>我们将这些都放入ctl_list.h文件当中，包括链表的定义，链表的接口，一些用到的宏定义。</p>
<p>为了能够方便的进行程序的设计，我们仍旧采用包裹函数的方式对某些操作进行简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;*接口包裹函数定义*&#x2F;<br><br>static void *Malloc(size_t size);<br>static List_node *Create_node(void); <br>static void Swap(void *a, void *b, int length);<br>static void Rev_show_list(List_node *node);<br></code></pre></td></tr></table></figure>

<p>我们常用到的操作函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;*接口包裹函数实现*&#x2F;<br><br>static void *Malloc(size_t size)<br>&#123;<br>    void *result &#x3D; malloc(size);<br>    if(result &#x3D;&#x3D; NULL)&#123;<br>        fprintf(stderr, &quot;the memory is full\n&quot;);<br>        exit(1);<br>    &#125;<br>    return result;<br>&#125;<br><br>static List_node *Create_node(void)    &#x2F;&#x2F;创建链表节点<br>&#123;<br>    List_node *node &#x3D; (List_node *)Malloc(sizeof(List_node));<br>    bzero(node, sizeof(List_node));<br><br>    return node;<br>&#125;<br><br>static void Swap(void *a, void *b, int length)<br>&#123;<br>    void *temp &#x3D; Malloc(length);<br>    memcpy(temp, a, length);<br>    memcpy(a, b, length);<br>    memcpy(b, temp, length);<br>    <br>    free(temp);<br>&#125;<br><br>static void Rev_show_list(List_node *node)<br>&#123;<br>   &#x2F;&#x2F;要打印当前节点，先打印其后续节点<br>   if(node !&#x3D; NULL)&#123;<br>       rev_show_list(node-&gt;next);<br>       printf(&quot;%d &quot;, node-&gt;data);    <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>宏定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;*控制链表宏定义*&#x2F;<br><br>#define TRUE               (1)<br>#define FALSE              (0)<br>#define ZERO               (0)<br>#define ONLY_ONE           (1)<br>#define TWO                (2)<br>#define get_data_size()    ((unsigned long)&amp;(((List_node *)0)-&gt;next))<br></code></pre></td></tr></table></figure>

<h3 id="三、链表接口的实现"><a href="#三、链表接口的实现" class="headerlink" title="三、链表接口的实现"></a><strong>三、链表接口的实现</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;1.链表的初始化<br>&#x2F;&#x2F;      | head | tail | count |<br>&#x2F;&#x2F;          \      &#x2F;      0<br>&#x2F;&#x2F;           \    &#x2F;<br>&#x2F;&#x2F;            NULL<br>List      *init_list(void)                            <br>&#123;<br>    List *list &#x3D; (List *)Malloc(sizeof(List));<br>    <br>    bzero(list, sizeof(List));    &#x2F;&#x2F;全部清零<br><br>    return list; <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;2. 链表的销毁<br>&#x2F;&#x2F;              list<br>&#x2F;&#x2F;             &#x2F;<br>&#x2F;&#x2F;         list_head  <br>&#x2F;&#x2F;          &#x2F;<br>&#x2F;&#x2F;      | head | tail | count |<br>&#x2F;&#x2F;          \         \   n + 1<br>&#x2F;&#x2F;             <br>&#x2F;&#x2F;            \          \<br>&#x2F;&#x2F;            node-&gt;node2-&gt;node3<br><br>void      destroy_list(List **list)                   <br>&#123;<br>    if(list &#x3D;&#x3D; NULL || *list &#x3D;&#x3D; NULL)&#123;<br>        return ;<br>    &#125;<br>   <br>    &#x2F;&#x2F;  链表删除步骤：<br>    &#x2F;&#x2F;  1.删除链表节点信息;<br>    while((*list)-&gt;count)&#123;   &#x2F;&#x2F;头部删除链表节点<br>        pop_front(*list);<br>    &#125;<br>    &#x2F;&#x2F;  2.删除链表控制信息.<br>    free(*list);<br>    *list &#x3D; NULL;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;3.1 头部插入<br>Boolean   push_front(List *list, int value)           <br>&#123;<br>    List_node *node &#x3D; NULL;<br>  <br>    if(list &#x3D;&#x3D; NULL)&#123; <br>        return FALSE;<br>    &#125;   <br><br>    &#x2F;&#x2F;创建节点并赋值<br>    node &#x3D; create_node();<br>    node-&gt;data &#x3D; value;<br><br>    &#x2F;&#x2F;   case1:<br>    &#x2F;&#x2F;      | head | tail | count |<br>    &#x2F;&#x2F;          \      &#x2F;      1<br>    &#x2F;&#x2F;           \    &#x2F;<br>    &#x2F;&#x2F;            node<br>    if(list-&gt;count &#x3D;&#x3D; ZERO)&#123;<br>        list-&gt;tail &#x3D; node;<br>    &#125;else&#123;<br>    &#x2F;&#x2F;   case2:<br>    &#x2F;&#x2F;      | head |              tail | count |<br>    &#x2F;&#x2F;          \                 &#x2F;       n + 1<br>    &#x2F;&#x2F;           \               &#x2F;<br>    &#x2F;&#x2F;            node-&gt;node2-&gt;node3<br>        node-&gt;next &#x3D; list-&gt;head;<br>    &#125;<br>    list-&gt;head &#x3D; node;<br>    list-&gt;count++;<br>    return TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;3.2 尾部插入<br>Boolean   push_back(List  *list, int value)           <br>&#123;<br>    List_node *node &#x3D; NULL;<br><br>    if(list &#x3D;&#x3D; NULL)&#123;<br>        return FALSE;<br>    &#125;<br>  <br>    node &#x3D; create_node();<br>    node-&gt;data &#x3D; value;<br><br>    &#x2F;&#x2F;   case1:<br>    &#x2F;&#x2F;      | head | tail | count |<br>    &#x2F;&#x2F;          \      &#x2F;      1<br>    &#x2F;&#x2F;           \    &#x2F;<br>    &#x2F;&#x2F;            node<br>    if(list-&gt;count &#x3D;&#x3D; ZERO)&#123;<br>       list-&gt;head &#x3D; list-&gt;tail &#x3D; node;<br>    &#125;else&#123;<br>        &#x2F;&#x2F;   case2:<br>        &#x2F;&#x2F;      | head |              tail | count |<br>        &#x2F;&#x2F;          \                 &#x2F;       n + 1<br>        &#x2F;&#x2F;           \               &#x2F;<br>        &#x2F;&#x2F;            node1-&gt;node2-&gt;node<br>        list-&gt;tail-&gt;next &#x3D; node;<br>        list-&gt;tail &#x3D; node;<br>    &#125;<br>    list-&gt;count++;<br>    return TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&#x2F;&#x2F;4.1 头部删除<br>Boolean   pop_front(List *list)                       <br>&#123;<br>    List_node *p_node &#x3D; NULL;<br><br>    if(list &#x3D;&#x3D; NULL || list-&gt;count &#x3D;&#x3D; ZERO)&#123;<br>        return FALSE;<br>    &#125;<br><br>    &#x2F;&#x2F;   case1:<br>    &#x2F;&#x2F;      | head | tail | count |<br>    &#x2F;&#x2F;          \      &#x2F;      1-&gt;0<br>    &#x2F;&#x2F;           \    &#x2F;<br>    &#x2F;&#x2F;            node<br>    <br>    &#x2F;&#x2F;   case2:<br>    &#x2F;&#x2F;      | head |              tail | count |<br>    &#x2F;&#x2F;          \                 &#x2F;       n-&gt; n - 1<br>    &#x2F;&#x2F;           \               &#x2F;<br>    &#x2F;&#x2F;            node1-&gt;node2-&gt;node3<br>    p_node &#x3D; list-&gt;head;<br>    if(list-&gt;count &#x3D;&#x3D; ONLY_ONE)&#123;<br>        list-&gt;head &#x3D; list-&gt;tail &#x3D; NULL; <br>    &#125;else&#123;<br>        list-&gt;head &#x3D; list-&gt;head-&gt;next;<br>    &#125;<br>    free(p_node);<br>    list-&gt;count--;<br>    return TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;4.2 尾部删除<br>Boolean   pop_back(List *list)                        <br>&#123;<br>    List_node *p_node &#x3D; NULL;<br><br>    if(list &#x3D;&#x3D; NULL || list-&gt;count &#x3D;&#x3D; ZERO)&#123; <br>        return FALSE;<br>    &#125;<br>   <br>    &#x2F;&#x2F;   case1:<br>    &#x2F;&#x2F;      | head | tail | count |<br>    &#x2F;&#x2F;          \      &#x2F;      1-&gt;0<br>    &#x2F;&#x2F;           \    &#x2F;<br>    &#x2F;&#x2F;            node<br>    <br>    &#x2F;&#x2F;   case2:<br>    &#x2F;&#x2F;      | head |              tail | count |<br>    &#x2F;&#x2F;          \                 &#x2F;       n-&gt; n - 1<br>    &#x2F;&#x2F;           \               &#x2F;<br>    &#x2F;&#x2F;            node1-&gt;node2-&gt;node3<br>    p_node &#x3D; list-&gt;head; <br>    if(list-&gt;count &#x3D;&#x3D; ONLY_ONE)&#123;    <br>        list-&gt;head &#x3D; list-&gt;tail &#x3D; NULL;<br>        free(p_node);<br>    &#125;else&#123;<br>        &#x2F;&#x2F;判断倒数第二个？<br>        &#x2F;&#x2F;   p_node-&gt;next &#x3D;&#x3D; list-&gt;tail<br>        while(p_node-&gt;next !&#x3D; list-&gt;tail)&#123;<br>            p_node &#x3D; p_node-&gt;next;<br>        &#125;<br>        free(list-&gt;tail);<br>        list-&gt;tail &#x3D; p_node;<br>        p_node-&gt;next &#x3D; NULL;<br>    &#125;<br>    list-&gt;count--;<br>    return TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;5.1 链表的查找<br>List_node *find_node(List *list, int value)<br>&#123;<br>    if(list &#x3D;&#x3D; NULL)<br>    &#123;<br>        return NULL;<br>    &#125;<br>    List_node *p &#x3D; list-&gt;head;<br>    while(p !&#x3D; NULL)<br>    &#123;<br>        if(p-&gt;data &#x3D;&#x3D; value)<br>        &#123;<br>            printf(&quot;found the value: %d\n&quot;, value);<br>            return p;<br>        &#125;<br>        p &#x3D; p-&gt;next;<br>    &#125;<br>    printf(&quot;No found!&quot;);<br>    return NULL;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;5.2 找到链表的倒数第num个节点<br>List_node *find_revise_node(List *list, int num)   <br>&#123;<br>    List_node *move &#x3D; NULL;<br>    int move_count &#x3D; 0;<br>    &#x2F;&#x2F;move + num &#x3D;&#x3D; count<br>    if(list &#x3D;&#x3D; NULL || num &lt;&#x3D; 0 || num &gt; list-&gt;count)&#123;<br>        return NULL;<br>    &#125;    <br><br>    move &#x3D; list-&gt;head;<br>    &#x2F;&#x2F;移动的步长<br>    move_count &#x3D; list-&gt;count - num;<br><br>    while(move_count--)&#123;<br>        move &#x3D; move-&gt;next;<br>    &#125;<br><br>    return move;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;5.3 找到链表的中间节点<br>    &#x2F;&#x2F; 1.) 快慢指针：<br>    &#x2F;&#x2F;<br>    &#x2F;&#x2F;       f  每次移动2步， s 每次移动1步<br>    &#x2F;&#x2F;       10  23  5  15  50  67  45  32  82<br>    &#x2F;&#x2F;<br>    &#x2F;&#x2F; 2.)   10 &#x2F;  2 &#x3D;&#x3D; 5<br>    &#x2F;&#x2F;       10 &gt;&gt; 1 &#x3D;&#x3D; 5<br>    &#x2F;&#x2F;<br>    &#x2F;&#x2F;       0000 1010   10<br>    &#x2F;&#x2F;            10 &gt;&gt; 1<br>    &#x2F;&#x2F;       0000 0101   5<br>List_node *find_mid_node(List *list)    <br>&#123;<br>    List_node *move &#x3D; NULL;<br>    int move_count &#x3D; 0;<br><br>    if(list &#x3D;&#x3D; NULL)&#123;<br>        return NULL;<br>    &#125;<br><br>    move &#x3D; list-&gt;head;<br>    move_count &#x3D; list-&gt;count &gt;&gt; 1;<br><br>    while(move_count--)&#123;<br>        move &#x3D; move-&gt;next;<br>    &#125;<br><br>    return move;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;6.1 链表节点的修改<br>void modify_node(List *list, int index, int value)<br>&#123;<br>    int count &#x3D; index;<br>    List_node *p &#x3D; list-&gt;head;<br>    <br>    if(list &#x3D;&#x3D; NULL || index &gt;&#x3D; list-&gt;count || index &lt; 0)<br>    &#123;<br>        return ;<br><br>    while(count--)<br>    &#123;<br>        p &#x3D; p-&gt;next;<br>    &#125;<br>    <br>    p-&gt;data &#x3D; value;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;6.2链表节点的插入<br>Boolean insert_node(List *list,int index, int value)<br>&#123;<br>    if(list &#x3D;&#x3D; NULL || index &gt; list-&gt;count || index &lt; 0)<br>    &#123;<br>        return FALSE;<br>    &#125;<br>    &#x2F;&#x2F;在最后则尾部插入<br>    if(index &#x3D;&#x3D; list-&gt;count)<br>    &#123;<br>        return push_back(list, value);<br>    &#125;<br>    &#x2F;&#x2F;在最前则头部插入<br>    if(index &#x3D;&#x3D; 0)<br>    &#123;<br>        return push_front(list, value);<br>    &#125;<br>    <br>    int count &#x3D;  index -1;<br>    List_node *p_node &#x3D; list-&gt;head;<br><br>    &#x2F;&#x2F;创建新节点<br>    List_node *node &#x3D; create_node();<br>    node-&gt;data &#x3D; value;<br>    <br>	&#x2F;&#x2F;寻找需插入的节点位置<br>    while(count--)<br>    &#123;<br>        p_node &#x3D; p_node-&gt;next;<br>    &#125;<br><br>	&#x2F;&#x2F;进行插入<br>    node-&gt;next &#x3D; p_node-&gt;next;<br>    p_node-&gt;next &#x3D; node;<br><br>    list-&gt;count++;<br>    return TRUE;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;6.3 在O（1）的时间复杂度删除节点<br>	&#x2F;&#x2F;由于是单链表，无法获取到前一个节点的位置，<br>	&#x2F;&#x2F;所以，我们在这里用后一个节点代替我们所需的节点。<br>void      delete_one_node(List *list, List_node *node)   <br>&#123;<br>	if(list &#x3D;&#x3D; NULL || node &#x3D;&#x3D; NULL)<br>	&#123;<br>	    return ;<br>	&#125;<br>	&#x2F;&#x2F;尾部删除<br>    if(node &#x3D;&#x3D; list-&gt;tail)<br>    &#123;<br>        pop_back(list);<br>        return ;<br>    &#125;<br>    List_node *p &#x3D; node-&gt;next;&#x2F;&#x2F;保存下一个节点位置<br><br>    node-&gt;data &#x3D; node-&gt;next-&gt;data; &#x2F;&#x2F;这个节点作为后一个的替代<br>    node-&gt;next &#x3D; node-&gt;next-&gt;next; &#x2F;&#x2F;直接指向下一个节点的后面<br>    free(p);<br>    list-&gt;count--;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&#x2F;&#x2F;7.1 升序排列<br> &#x2F;&#x2F;我们在这里用到了一种新的办法求我们的结构体大小，定义在宏里：<br> <br> &#x2F;&#x2F; ((unsigned long)&amp;(((List_node *)0)-&gt;next))<br> &#x2F;&#x2F;    <br> &#x2F;&#x2F;                    (List_node *)0          &#x2F;&#x2F;指向首地址在0的List_node的指针<br> &#x2F;&#x2F;                   ((List_node *)0)-&gt;next)  &#x2F;&#x2F;取next则指向了它的下一个<br> &#x2F;&#x2F;                 &amp;(((List_node *)0)-&gt;next)) &#x2F;&#x2F;取地址，得到的是这个地址，由于首地址，则正好是大小<br> &#x2F;&#x2F; ((unsigned long)&amp;(((List_node *)0)-&gt;next)) &#x2F;&#x2F;unsigned long 类型转换，得到就是大小<br> &#x2F;&#x2F; sizeof(List_node) - sizeof(List_node *);<br> <br>   &#x2F;&#x2F;内存分配，结构体里内存对齐现象：<br>    &#x2F;&#x2F; int               data;  &#x2F;&#x2F; 0   1   2   3<br>    &#x2F;&#x2F;                          &#x2F;&#x2F; 4   5   6   7<br>    &#x2F;&#x2F; struct List_Node *next;  &#x2F;&#x2F; 8   9  10  11<br>    &#x2F;&#x2F;                            12  13  14  15<br>    <br>void      sort_list_ascend(List *list)                <br>&#123;<br>    List_node *p_node &#x3D; NULL;<br>    List_node *q_node &#x3D; NULL;<br>    unsigned long data_size &#x3D; 0;<br><br>    if(list &#x3D;&#x3D; NULL || list-&gt;count &lt; TWO)&#123;<br>        return ;<br>    &#125;<br><br><br>    data_size &#x3D; get_data_size();    &#x2F;&#x2F;求得数据区域得大小<br>    for(p_node &#x3D; list-&gt;head; p_node-&gt;next; p_node &#x3D; p_node-&gt;next)&#123;<br>        for(q_node &#x3D; p_node-&gt;next; q_node ; q_node &#x3D; q_node-&gt;next)&#123;<br>            if(p_node-&gt;data &gt; q_node-&gt;data)&#123; <br>                swap(p_node, q_node, data_size);                <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&#x2F;&#x2F;7.2 降序排列<br>  &#x2F;&#x2F;和升序类似<br>void      sort_list_descend(List *list)               <br>&#123;<br>    List_node *p_node &#x3D; NULL;<br>    List_node *q_node &#x3D; NULL;<br>    unsigned long data_size &#x3D; 0;<br><br>    if(list &#x3D;&#x3D; NULL || list-&gt;count &lt; TWO)&#123;<br>        return ;<br>    &#125;<br><br>    data_size &#x3D; get_data_size();    &#x2F;&#x2F;求得数据区域得大小<br>    for(p_node &#x3D; list-&gt;head; p_node-&gt;next; p_node &#x3D; p_node-&gt;next)&#123;<br>        for(q_node &#x3D; p_node-&gt;next; q_node ; q_node &#x3D; q_node-&gt;next)&#123;<br>            if(p_node-&gt;data &lt; q_node-&gt;data)&#123; <br>                swap(p_node, q_node, data_size);                <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;8.1 显示链表信息<br>void      show_list(List *list)                       <br>&#123;<br>    List_node *p_node &#x3D; NULL;<br><br>    if(list !&#x3D; NULL &amp;&amp; list-&gt;count !&#x3D; ZERO)&#123; <br>        for(p_node &#x3D; list-&gt;head; p_node; p_node &#x3D; p_node-&gt;next)&#123; <br>            printf(&quot;%d &quot;, p_node-&gt;data);<br>        &#125;<br>        printf(&quot;\n&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;8.2 逆序输出链表信息<br>void      reverse_show_list(List *list)    <br>&#123;<br>    if(list &#x3D;&#x3D; NULL || list-&gt;count &#x3D;&#x3D; ZERO)&#123;<br>        return ;<br>    &#125;  <br>    &#x2F;&#x2F; .h中定义的递归（先递归再输出）<br>    Rev_show_list(list-&gt;head);<br>    printf(&quot;\n&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;9 得到链表节点数量<br>  &#x2F;&#x2F;这是一个有控制信息的链表，有关于节点数量的变量<br>int       get_list_count(List *list)                  <br>&#123;<br>    if(list &#x3D;&#x3D; NULL)&#123; <br>        return -1;<br>    &#125;<br>    return list-&gt;count;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;&#x2F;10 合并两个有序链表<br>    &#x2F;&#x2F;l1    | head |              tail | count |<br>    &#x2F;&#x2F;          \                 &#x2F;       n-&gt; n - 1<br>    &#x2F;&#x2F;           \               &#x2F;<br>    &#x2F;&#x2F;            node1-&gt;node2-&gt;node3<br>    &#x2F;&#x2F;<br>    &#x2F;&#x2F;<br>    &#x2F;&#x2F;l2    | head |              tail | count |<br>    &#x2F;&#x2F;          \                 &#x2F;       n-&gt; n - 1<br>    &#x2F;&#x2F;           \               &#x2F;<br>    &#x2F;&#x2F;            node1-&gt;node2-&gt;node3<br>    &#x2F;&#x2F;<br>List      *merge_two_lists(List *list1, List *list2)    <br>&#123;<br>    List *result &#x3D; NULL;<br>    List_node *list1_move &#x3D; NULL;   <br>    List_node *list2_move &#x3D; NULL;   <br><br>    if(list1 &#x3D;&#x3D; NULL || list2 &#x3D;&#x3D; NULL)&#123;<br>        return result;<br>    &#125;<br><br>    result &#x3D; init_list();   &#x2F;&#x2F;结果链表得初始化<br><br>    list1_move &#x3D; list1-&gt;head;<br>    list2_move &#x3D; list2-&gt;head;<br><br>    &#x2F;&#x2F;如果两个链表都没有遍历完，进行比较<br>    while(list1_move !&#x3D; NULL &amp;&amp; list2_move !&#x3D; NULL)&#123;<br>        if(list1_move-&gt;data &lt;&#x3D; list2_move-&gt;data)&#123;<br>            push_back(result, list1_move-&gt;data);<br>            list1_move &#x3D; list1_move-&gt;next;<br>        &#125;else&#123;<br>            push_back(result, list2_move-&gt;data);<br>            list2_move &#x3D; list2_move-&gt;next;<br>        &#125;<br>    &#125;<br><br>    &#x2F;&#x2F;当两个链表中任何一个遍历结束，则把另外一个进行尾部添加<br>    while(list2_move !&#x3D; NULL)&#123;<br>        push_back(result, list2_move-&gt;data);<br>        list2_move &#x3D; list2_move-&gt;next;<br>    &#125;<br><br>    while(list1_move !&#x3D; NULL)&#123;<br>        push_back(result, list1_move-&gt;data);<br>        list1_move &#x3D; list1_move-&gt;next;<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&#x2F;&#x2F;11&#x2F;&#x2F;合并两个有序链表（递归）<br>    &#x2F;&#x2F;   <br>    &#x2F;&#x2F;l1            node1-&gt;node2-&gt;node3<br>    &#x2F;&#x2F;<br>    &#x2F;&#x2F;     l-&gt;node1-&gt;node4...<br>    &#x2F;&#x2F;    <br>    &#x2F;&#x2F;l2            node4-&gt;node5-&gt;node6<br>    &#x2F;&#x2F;<br>List      *merge_two_lists_recure(List *list1, List *list2)    <br>&#123;<br>    List *node &#x3D; NULL;<br>    List *l  &#x3D; init_list();<br>    List *l1 &#x3D; list1;<br>    List *l2 &#x3D; list2;<br><br>    if(l1-&gt;count &#x3D;&#x3D; 0)<br>    &#123;<br>        return list2;<br>    &#125;<br>    if(l2-&gt;count &#x3D;&#x3D; 0)<br>    &#123;<br>        return list1;<br>    &#125;<br><br>    &#x2F;&#x2F;若l1当前head满足较小情况，将l指向l1,让l1指向l1的下一个节点，进入递归比较l1-&gt;head-&gt;next形成的链表与l2再进行比较，返回的node链表是后面节点的新链表;<br>    if(l1-&gt;head-&gt;data &lt; l2-&gt;head-&gt;data)<br>    &#123;<br>        l-&gt;head &#x3D; l1-&gt;head;<br>        l1-&gt;head &#x3D; l1-&gt;head-&gt;next;<br>        l1-&gt;count --;<br>        node &#x3D; merge_two_lists_recure(l1, l2);<br>    &#125;<br>    else<br>    &#123;<br>        l-&gt;head &#x3D; l2-&gt;head;<br>        l2-&gt;head &#x3D; l2-&gt;head-&gt;next;<br>        l2-&gt;count--;<br>        node &#x3D; merge_two_lists_recure(l1, l2);<br>    &#125;<br>    &#x2F;&#x2F;完成递归后，l指向node组成的新链表;<br>    l-&gt;head-&gt;next &#x3D; node-&gt;head;<br>    l-&gt;count &#x3D; node-&gt;count +1;<br>    return l;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>&#x2F;&#x2F;12 逆置一个链表<br>    &#x2F;&#x2F;因为会改变结构，为了不失去对后面的节点的信息，使用了三个指针，交换前两个，不丢失第三个 。<br>    &#x2F;&#x2F;<br>    &#x2F;&#x2F;      | head |              tail | count |<br>    &#x2F;&#x2F;          \                   \      n-&gt; n - 1<br>    &#x2F;&#x2F;           \                   \<br>    &#x2F;&#x2F;            node1-&gt;node2-&gt;node3-&gt;node4<br>    &#x2F;&#x2F;             |      |       |<br>    &#x2F;&#x2F;             p      q       m<br>    &#x2F;&#x2F;<br>    &#x2F;&#x2F;            node1&lt;-node2 node3-&gt;node4<br>    &#x2F;&#x2F;             |      |       |      |<br>    &#x2F;&#x2F;             p      q       m      |<br>    &#x2F;&#x2F;                    p       q      m   <br>    &#x2F;&#x2F;<br>    <br>List      *reverse_list(List *list)    <br>&#123;<br>    List_node *p_node &#x3D; NULL;<br>    List_node *q_node &#x3D; NULL;<br>    List_node *m_node &#x3D; NULL;<br><br>    if(list &#x3D;&#x3D; NULL || list-&gt;count &lt; TWO)&#123;<br>        return list;<br>    &#125; <br>    &#x2F;&#x2F;两个节点<br>    if(list-&gt;count &#x3D;&#x3D; TWO)&#123;<br>        list-&gt;tail-&gt;next &#x3D; list-&gt;head;<br>        list-&gt;head-&gt;next &#x3D; NULL;<br>    &#125;else&#123;    &#x2F;&#x2F;三个节点<br>        p_node &#x3D; list-&gt;head;<br>        q_node &#x3D; p_node-&gt;next;<br>        m_node &#x3D; q_node-&gt;next;<br>        p_node-&gt;next &#x3D; NULL;<br>        do&#123;<br>            q_node-&gt;next &#x3D; p_node;   &#x2F;&#x2F;让中间指针的next指向前一个<br>            p_node &#x3D; q_node;    &#x2F;&#x2F;指针整体向后搬移<br>            q_node &#x3D; m_node;<br>            m_node &#x3D; m_node-&gt;next;<br>        &#125;while(m_node !&#x3D; NULL);<br>        q_node-&gt;next &#x3D; p_node;<br>    &#125;<br>    &#x2F;&#x2F;交换头尾指针<br>    swap(&amp;(list-&gt;head), &amp;(list-&gt;tail), sizeof(List_node *));<br>    return list;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;13 链表的拷贝<br>  &#x2F;&#x2F;使用了尾插法依次将元素插入<br>List      *list_dump(List *list)    <br>&#123;<br>    List * new_list &#x3D; init_list();<br>    List_node * node &#x3D; list-&gt;head;<br>    for(node &#x3D; list-&gt;head; node; node &#x3D; node-&gt;next)<br>    &#123;<br>        push_back(new_list, node-&gt;data);<br>    &#125;<br>    return new_list;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;14 判断链表是否有交点<br>  &#x2F;&#x2F;若两个链表有交点，则尾节点一定是同一个。<br>  &#x2F;&#x2F;<br>  &#x2F;&#x2F;  l1-&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt;<br>  &#x2F;&#x2F;                \<br>  &#x2F;&#x2F;                 \     <br>  &#x2F;&#x2F;                 &#x2F;  &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt;<br>  &#x2F;&#x2F;  l2-&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; <br>  &#x2F;&#x2F;<br>Boolean   is_list_intersect(List *list1, List *list2)    <br>&#123;<br>    if(list1 &#x3D;&#x3D; NULL || list2 &#x3D;&#x3D; NULL)&#123;<br>        return FALSE;<br>    &#125;<br>&#x2F;&#x2F;    <br>    if( list1-&gt;tail &#x3D;&#x3D; list2-&gt;tail)<br>    &#123;<br>        printf(&quot;intersect\n&quot;);<br>        return TRUE;<br>    &#125;<br>    else<br>    &#123;<br>        printf(&quot;nothing\n&quot;);<br>        return FALSE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;15 得到第一个交点<br>  &#x2F;&#x2F;             l1 &#x3D;&gt;<br>  &#x2F;&#x2F;                    \     <br>  &#x2F;&#x2F;                    &#x2F;   &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt;<br>  &#x2F;&#x2F;     l2 &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; &#x3D;&gt; <br>  &#x2F;&#x2F;     长度不等，先获得两个链表都离相遇点长度相等的地方开始依次比较。<br>List_node *get_first_common_node(List *list1, List *list2)    <br>&#123;<br>    int list1_len &#x3D; 0;<br>    int list2_len &#x3D; 0;<br>    int distance &#x3D; 0;<br>    List_node *p_node &#x3D; NULL;<br>    List_node *q_node &#x3D; NULL;<br>    <br><br>    if(!is_list_intersect(list1, list2))&#123;    &#x2F;&#x2F;判断两个链表是否有交点<br>        return NULL;<br>    &#125;<br>   <br>    list1_len &#x3D; list1-&gt;count;<br>    list2_len &#x3D; list2-&gt;count;<br><br>    p_node &#x3D; list1-&gt;head;<br>    q_node &#x3D; list2-&gt;head;<br><br>    &#x2F;&#x2F;判断较长链表并首先进行移动<br>    if(list1_len &gt;&#x3D; list2_len)&#123;<br>        distance &#x3D; list1_len - list2_len;<br>        while(distance--)&#123; <br>            p_node &#x3D; p_node-&gt;next;<br>        &#125;<br>    &#125;else&#123;<br>        distance &#x3D; list2_len - list1_len;<br>        while(distance--)&#123;<br>            q_node &#x3D; q_node-&gt;next;<br>        &#125;<br>    &#125;<br><br>    &#x2F;&#x2F;依次对对应节点进行判断是否相等，如果相等则是第一个相交节点<br>    while(p_node !&#x3D; q_node)&#123;<br>        p_node &#x3D; p_node-&gt;next;<br>        q_node &#x3D; q_node-&gt;next;<br>    &#125;<br>   <br>    return p_node;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;16 判断一个链表是否有环<br>  &#x2F;&#x2F;<br>  &#x2F;&#x2F;   - - - 、  <br>  &#x2F;&#x2F;          \    - - - - 、<br>  &#x2F;&#x2F;           \ &#x2F;          |<br>  &#x2F;&#x2F;            \          &#x2F;<br>  &#x2F;&#x2F;             &#96; - - - -<br>  &#x2F;&#x2F;<br>Boolean has_circle(List *list)                                <br>&#123;<br>    List_node *p &#x3D; list-&gt;head;  &#x2F;&#x2F;slow<br>    List_node *q &#x3D; list-&gt;head;  &#x2F;&#x2F;fast<br>    while(p !&#x3D; NULL &amp;&amp; q !&#x3D; NULL &amp;&amp; q-&gt;next !&#x3D;NULL)<br>    &#123;<br>        p &#x3D; p-&gt;next;        &#x2F;&#x2F;一次一步<br>        q &#x3D; q-&gt;next-&gt;next;  &#x2F;&#x2F;一次两步<br><br>        &#x2F;&#x2F;如果有环，则一定会相遇<br>        if(p &#x3D;&#x3D; q)<br>        &#123;<br>            printf(&quot;we found circle!\n&quot;);<br>            return TRUE;<br>        &#125;<br>    &#125;<br>    printf(&quot;no circle!\n&quot;);<br>    return FALSE;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;17 找到带环链表的环入口节点<br>  &#x2F;&#x2F;<br>  &#x2F;&#x2F;   - - - 、  <br>  &#x2F;&#x2F;          \    - - - - 、<br>  &#x2F;&#x2F;           \ &#x2F;          |<br>  &#x2F;&#x2F;            \          &#x2F;<br>  &#x2F;&#x2F;        入口点 &#96; - -*- -<br>  &#x2F;&#x2F;                   \<br>  &#x2F;&#x2F;                     相遇点<br>  &#x2F;&#x2F;            |&lt;-x-&gt;|<br>  &#x2F;&#x2F;  |&lt;---a---&gt;|&lt;-----r----&gt;|<br>  &#x2F;&#x2F;  |&lt;----------L---------&gt;|<br>  &#x2F;&#x2F; 我们设整个链表长L，入口点与相遇点长x，起点到入口点长度为a;<br>  &#x2F;&#x2F; 快指针走的长度是慢指针的2倍，由于快指针可能不止走了一圈;<br>  &#x2F;&#x2F; 慢指针走了s步，即快指针走了2s步。<br>  &#x2F;&#x2F;<br>  &#x2F;&#x2F; ∵ 2s &#x3D; s + nr ;<br>  &#x2F;&#x2F; ∴ s &#x3D; nr;<br>  &#x2F;&#x2F;<br>  &#x2F;&#x2F;   a + x &#x3D; nr<br>  &#x2F;&#x2F;   a + x &#x3D; nr &#x3D; (n-1)r + r &#x3D;  (n-1)r + L -a<br>  &#x2F;&#x2F;   a &#x3D; (n-1)r + (L -a -x)<br>  &#x2F;&#x2F;   链表从头到环入口点长度 &#x3D; (n -1)环长 + 相遇点到环入口长度<br>  &#x2F;&#x2F;   所以， 从链表头和相遇点各设一个一步长的指针，必定会在相遇点回合。<br>  &#x2F;&#x2F;<br>List_node *find_circle_first_node(List *list)                  <br>&#123;<br>    List_node * entry &#x3D; NULL;<br>    if(!has_circle(list))<br>    &#123;<br>        return NULL;<br>    &#125;<br>    List_node *p &#x3D; list-&gt;head;  &#x2F;&#x2F;slow<br>    List_node *q &#x3D; list-&gt;head;  &#x2F;&#x2F;fast<br>    while(p !&#x3D; NULL &amp;&amp; q !&#x3D; NULL &amp;&amp; q-&gt;next !&#x3D;NULL)<br>    &#123;<br>        p &#x3D; p-&gt;next;<br>        q &#x3D; q-&gt;next-&gt;next;<br>        if(p &#x3D;&#x3D; q)<br>        &#123;<br>            break;    &#x2F;&#x2F;相遇点p和q<br>        &#125;<br>    &#125;<br>    &#x2F;&#x2F;p为相遇点开始<br>    q &#x3D; list-&gt;head;   &#x2F;&#x2F;q从链表头开始<br>    while(q !&#x3D; p)<br>    &#123;<br>        p &#x3D;p-&gt;next;<br>        q &#x3D;q-&gt;next;<br>    &#125;<br>    printf(&quot;we found the node is %d\n&quot;, q-&gt;data);<br>    return q;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="四、测试功能"><a href="#四、测试功能" class="headerlink" title="四、测试功能"></a><strong>四、测试功能</strong></h3><p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs plain">#include &quot;list.h&quot;<br><br><br>int main()<br>&#123;<br>    int i &#x3D; 0;<br>    int num &#x3D; 0;<br>    List *list &#x3D; NULL;<br>    List *list1 &#x3D; NULL;<br>    List *list2 &#x3D; NULL;<br>    List_node * node &#x3D; NULL;<br>    <br>    printf(&quot;1.init_list:\n&quot;);<br>    list &#x3D; init_list();<br>    list1 &#x3D; init_list();<br>    list2 &#x3D; init_list();<br>    <br>    printf(&quot;3.1 list1 push_front :\n&quot;);<br>    for(i &#x3D; 0; i &lt; 6; i++)<br>    &#123;<br>        push_front(list1, rand()%100);<br>    &#125;<br><br>    show_list(list1);<br>    <br><br>    printf(&quot;3.2 list2 push_back:\n&quot;);<br>    for(i &#x3D; 0; i &lt; 4; i++)<br>    &#123;<br>        push_back(list2, rand()%100);<br>    &#125;<br>    show_list(list2);<br><br><br>    printf(&quot;4.1 list1 pop_front:\n&quot;);<br>    pop_front(list1);<br>    show_list(list1);<br><br>    printf(&quot;4.2 list2 pop_back:\n&quot;);<br>    pop_back(list2);<br>    show_list(list2);<br>    <br>    printf(&quot;7.1 sort_list1_ascend:\n&quot;);                   <br>    sort_list_ascend(list1);                  <br>    show_list(list1);<br>    <br>    printf(&quot;7.2 sort_list2_descend:\n&quot;);                   <br>    sort_list_descend(list2);                  <br>    show_list(list2);<br><br>    printf(&quot;12 reverse_list2:\n&quot;);<br>    reverse_list(list2);<br>    show_list(list2);<br>    <br>#if 0<br>    printf(&quot;10. list : merge_two_lists(list1, list2):\n&quot;);<br>    list &#x3D; merge_two_lists(list1, list2);<br>    show_list(list);<br>#endif<br><br>#if 1<br>    printf(&quot;11. list : merge_two_lists_recure(list1, list2):\n&quot;);<br>    list &#x3D; merge_two_lists_recure(list1, list2);<br>    show_list(list);<br>#endif<br>         <br>    printf(&quot;8.1 show_list(list);\n&quot;);      <br>    show_list(list);<br><br><br>    printf(&quot;8.2 reverse_show_list(list);\n&quot;);<br>    reverse_show_list(list);<br>#if 1 <br>    printf(&quot;find_node:\n&quot;);<br>    printf(&quot;which one?(value to find)\n&quot;); <br>    scanf(&quot;%d&quot;,&amp;num);<br>    printf(&quot;found num of list is :%d \n&quot;,find_node(list, num)-&gt;data);<br>#endif<br><br>#if 1<br>    printf(&quot;find_revise_node:\n&quot;);     <br>    printf(&quot;which one index ?(reverse)\n&quot;); <br>    scanf(&quot;%d&quot;,&amp;num);<br>    printf(&quot;reverse num of list is :%d \n&quot;,find_revise_node(list, num)-&gt;data);<br>#endif<br>    printf(&quot;5.3 find_mid_node(list):\n&quot;) ;<br>    printf(&quot;%d \n&quot;,find_mid_node(list)-&gt;data);<br><br>    printf(&quot;9. get_list_count:\n&quot;); <br>    printf(&quot;the count of list is :%d\n&quot;, get_list_count(list));<br><br>#if 1  <br>    printf(&quot;6.3 delete_one_node:&quot;);<br>    printf(&quot;which one?(to delete)\n&quot;); <br>    scanf(&quot;%d&quot;,&amp;num);<br>    node &#x3D; create_node();<br>    node &#x3D; find_node(list,num);<br>    delete_one_node(list, node);<br>    show_list(list);<br>#endif<br><br>#if 1<br>    printf(&quot;6.1 modify_node :\n&quot;);<br>    modify_node(list, 1, 26);<br>    show_list(list);<br>#endif<br><br>#if 1<br>    printf(&quot;6.2 insert_node: \n&quot;);<br>    insert_node(list, 2, 18);<br>    show_list(list);<br>#endif <br><br>#if 1<br>    printf(&quot;16. has_circle:\n&quot;);<br>    &#x2F;&#x2F;list-&gt;head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next &#x3D; list-&gt;head-&gt;next;<br><br>    if(has_circle(list))<br>    &#123;<br>        printf(&quot;17 find_circle_first_node:\n&quot;);<br>        find_circle_first_node(list);<br>    &#125;<br>#endif<br>    printf(&quot;13. list1:list_dump(list)\n&quot;);<br>    list1 &#x3D; list_dump(list);<br>    printf(&quot;list1: &quot;);<br>    show_list(list1);<br>    <br>    printf(&quot;14. is_list_intersect:\n&quot;);<br>    <br>    if(is_list_intersect(list1, list))<br>    &#123;<br>        printf(&quot;the common node: %d\n&quot;,get_first_common_node(list1, list));<br>    &#125;<br><br>    printf(&quot;2. destroy_list:\n&quot;);<br>    destroy_list(&amp;list1);<br>    destroy_list(&amp;list2);<br>    destroy_list(&amp;list);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs plain">root@aemonair:&#x2F;ctl_list# .&#x2F;bin&#x2F;list <br>1.init_list:<br>3.1 list1 push_front :<br>35 93 15 77 86 83 <br>3.2 list2 push_back:<br>86 92 49 21 <br>4.1 list1 pop_front:<br>93 15 77 86 83 <br>4.2 list2 pop_back:<br>86 92 49 <br>7.1 sort_list1_ascend:<br>15 77 83 86 93 <br>7.2 sort_list2_descend:<br>92 86 49 <br>12 reverse_list2:<br>49 86 92 <br>11. list : merge_two_lists_recure(list1, list2):<br>15 49 77 83 86 86 92 93 <br>8.1 show_list(list);<br>15 49 77 83 86 86 92 93 <br>8.2 reverse_show_list(list);<br>93 92 86 86 83 77 49 15 <br>find_node:<br>which one?(value to find)<br>92<br>found the value: 92<br>found num of list is :92 <br>find_revise_node:<br>which one index ?(reverse)<br>2<br>reverse num of list is :92 <br>5.3 find_mid_node(list):<br>86 <br>9. get_list_count:<br>the count of list is :8<br>6.3 delete_one_node:which one?(to delete)<br>92<br>found the value: 92<br>15 49 77 83 86 86 93 <br>6.1 modify_node :<br>15 26 77 83 86 86 93 <br>6.2 insert_node: <br>15 26 18 77 83 86 86 93 <br>16. has_circle:<br>no circle!<br>13. list1:list_dump(list)<br>list1: 15 26 18 77 83 86 86 93 <br>14. is_list_intersect:<br>nothing<br>2. destroy_list:<br></code></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>至此。我们完成了对<em>带控制信息链表</em>的定义，实现，测试;<br>我们会发现加上控制信息之后，一些操作被封装起来，有可能更加便捷。<br>这是一种思路，一种方法。<br>以上解法也不一定是最简便快捷的，只是其中一种实现而已。<br>我们还将继续对数据结构进行进一步的探讨。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:v.aemonair@gmail.com">Air</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aemonair.github.io/2016/05/31/Data_Structure_02_Single_Linked_List_With_Control/">http://aemonair.github.io/2016/05/31/Data_Structure_02_Single_Linked_List_With_Control/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Aemonair.github.io" target="_blank">Aemonair</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStruct/">DataStruct</a><a class="post-meta__tags" href="/tags/LinkedList/">LinkedList</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429124647_green_tree.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2016/06/03/Data_Structure_03_Double_Linked_List/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429115843_DataStruct_doubly_linked_list.gif" onerror="onerror=null;src='/img/404.link.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构C语言实现3.双端链表</div></div></a></div><div class="next-post pull_right"><a href="/2016/05/31/Data_Structure_01_Single_Linked_List/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429113842_DataStruct_Linked_list1.jpg" onerror="onerror=null;src='/img/404.link.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构C语言实现1.单链表</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2016/06/16/Data_Structure_04_Double_Linked_List_Package/" title="数据结构C语言实现4.进一步封装的双向链表"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429120329_datastruct_4_doubly_linkedlist.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-04-29</div><div class="relatedPosts_title">数据结构C语言实现4.进一步封装的双向链表</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/31/Data_Structure_01_Single_Linked_List/" title="数据结构C语言实现1.单链表"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429113842_DataStruct_Linked_list1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-04-29</div><div class="relatedPosts_title">数据结构C语言实现1.单链表</div></div></a></div><div class="relatedPosts_item"><a href="/2016/06/17/Data_Structure_05_General_Stack/" title="数据结构C语言实现5.通用栈"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429120559_photo-of-rocks-piled-on-top-of-each-other.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-04-29</div><div class="relatedPosts_title">数据结构C语言实现5.通用栈</div></div></a></div><div class="relatedPosts_item"><a href="/2016/06/18/Data_Structure_06_General_Queue/" title="数据结构C语言实现6.通用队列"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429121008_people-in-line-1604200.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-04-29</div><div class="relatedPosts_title">数据结构C语言实现6.通用队列</div></div></a></div><div class="relatedPosts_item"><a href="/2016/06/03/Data_Structure_03_Double_Linked_List/" title="数据结构C语言实现3.双端链表"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429115843_DataStruct_doubly_linked_list.gif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-04-29</div><div class="relatedPosts_title">数据结构C语言实现3.双端链表</div></div></a></div><div class="relatedPosts_item"><a href="/2016/06/25/Data_Structure_08_General_List/" title="数据结构C语言实现8.广义表"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting/images/20200429121824_Datastruct_List.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-04-29</div><div class="relatedPosts_title">数据结构C语言实现8.广义表</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Air</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">4th ~</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>