<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>数据结构2.带控制信息的链表 | Aemonair</title><meta name="description" content="数据结构2.带控制信息的链表"><meta name="keywords" content="DataStruct,LinkedList"><meta name="author" content="Air,v.aemonair@gmail.com"><meta name="copyright" content="Air"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="http://ta.qq.com"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构2.带控制信息的链表"><meta name="twitter:description" content="数据结构2.带控制信息的链表"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><meta property="og:type" content="article"><meta property="og:title" content="数据结构2.带控制信息的链表"><meta property="og:url" content="http://aemonair.github.io/2016/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E5%B8%A6%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E9%93%BE%E8%A1%A8/"><meta property="og:site_name" content="Aemonair"><meta property="og:description" content="数据结构2.带控制信息的链表"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://aemonair.github.io/2016/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E5%B8%A6%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E9%93%BE%E8%A1%A8/"><link rel="prev" title="数据结构3.双端链表" href="http://aemonair.github.io/2016/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8/"><link rel="next" title="数据结构1.单链表" href="http://aemonair.github.io/2016/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841_%E5%8D%95%E9%93%BE%E8%A1%A8/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?05af6f3318bdeb655af3eaa698a89a71";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-160152781-1', 'auto');
ga('send', 'pageview');
</script><script src="http://tajs.qq.com/stats?sId=66528155" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Aemonair</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#引言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">引言</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#本文的所有源程序可以在single-control-list上得到。"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">** 本文的所有源程序可以在single_control_list上得到。**</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#一、链表数据类型的定义"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">一、链表数据类型的定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二、链表的接口："><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">二、链表的接口：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#三、链表接口的实现"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">三、链表接口的实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#四、测试功能"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">四、测试功能</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#本文的所有源程序可以在single-control-list上得到。"><span class="toc-number">1.1.</span> <span class="toc-text">** 本文的所有源程序可以在single_control_list上得到。**</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一、链表数据类型的定义"><span class="toc-number">2.</span> <span class="toc-text">一、链表数据类型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、链表的接口："><span class="toc-number">3.</span> <span class="toc-text">二、链表的接口：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、链表接口的实现"><span class="toc-number">4.</span> <span class="toc-text">三、链表接口的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、测试功能"><span class="toc-number">5.</span> <span class="toc-text">四、测试功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png)"><div id="post-info"><div id="post-title"><div class="posttitle">数据结构2.带控制信息的链表</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2016-05-31<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-06</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Study/">Study</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h3><p>在上一篇博客<a href="http://blog.csdn.net/aemonair/article/details/51518059" target="_blank" rel="noopener">数据结构1.单链表</a>中，我们对链表相对数组的优缺点进行了比较。<br>而且，我们发现，链表是一种物理存储单元上非连续、非顺序的存储结构，所以，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<br>若是想要对链表中的其中一个元素进行操作，通常都需要<code>p_node = p_node->next;</code>的循环进行。  </p>
<blockquote>
<p>计算机科学领域的任何问题，都可以通过增加一个间接中间层来解决。<br>Any problems in computer science can be soved by another layer of indirection.  </p>
</blockquote>
<p>   所以，我们在定义这个链表的时候，可以给链表加上一层控制信息。如下：</p>
<h4 id="本文的所有源程序可以在single-control-list上得到。"><a href="#本文的所有源程序可以在single-control-list上得到。" class="headerlink" title="** 本文的所有源程序可以在single_control_list上得到。**"></a>** 本文的所有源程序可以在<a href="https://github.com/aemonair/Data_Struct/tree/master/single_control_list" target="_blank" rel="noopener">single_control_list</a>上得到。**</h4><h3 id="一、链表数据类型的定义"><a href="#一、链表数据类型的定义" class="headerlink" title="一、链表数据类型的定义"></a><strong>一、链表数据类型的定义</strong></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*链表数据类型定义*/</span><br><span class="line"></span><br><span class="line">struct List_node;    //声明一个类型</span><br><span class="line"></span><br><span class="line">//链表控制信息</span><br><span class="line">typedef struct List</span><br><span class="line">{</span><br><span class="line">    struct List_node *head;    //指向链表头部</span><br><span class="line">    struct List_node *tail;    //指向链表尾部</span><br><span class="line">    int              count;    //链表节点数量</span><br><span class="line">}List;</span><br><span class="line"></span><br><span class="line">//链表节点信息</span><br><span class="line">typedef struct List_node</span><br><span class="line">{</span><br><span class="line">    int               data;    //数据域</span><br><span class="line">    struct List_node *next;    //指针域</span><br><span class="line">}List_node;</span><br></pre></td></tr></tbody></table></figure></div>

<p>这样我们可以看到，已经可以直接获取到链表节点个数以及指向尾部节点的指针。我们可以用来做什么呢？</p>
<h3 id="二、链表的接口："><a href="#二、链表的接口：" class="headerlink" title="二、链表的接口："></a><strong>二、链表的接口：</strong></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/********链表的接口********/</span><br><span class="line"></span><br><span class="line">List      *init_list(void)                                 ;    //1.  链表的初始化</span><br><span class="line">void      destroy_list(List **list)                        ;    //2.  链表的销毁</span><br><span class="line">Boolean   push_front(List *list, int value)                ;    //3.1 头部插入</span><br><span class="line">Boolean   push_back(List  *list, int value)                ;    //3.2 尾部插入</span><br><span class="line">Boolean   pop_front(List *list)                            ;    //4.1 头部删除</span><br><span class="line">Boolean   pop_back(List *list)                             ;    //4.2 尾部删除</span><br><span class="line">List_node *find_node(List *list, int value)                ;    //5.1 链表的查找</span><br><span class="line">List_node *find_revise_node(List *list, int num)           ;    //5.2 找到链表的倒数第num个节点</span><br><span class="line">List_node *find_mid_node(List *list)                       ;    //5.3 找到链表的中间节点</span><br><span class="line">void      modify_node(List *list, int value)               ;    //6.1 链表节点的修改</span><br><span class="line">Boolean   insert_node(List *list, int index, int value)    ;    //6.2 链表节点的插入(下标)</span><br><span class="line">void      delete_one_node(List *list, List_node *node)     ;    //6.3 在O（1）的时间复杂度删除节点</span><br><span class="line">void      sort_list_ascend(List *list)                     ;    //7.1 升序</span><br><span class="line">void      sort_list_descent(List *list)                    ;    //7.2 降序排列</span><br><span class="line">void      show_list(List *list)                            ;    //8.1 显示链表信息</span><br><span class="line">void      reverse_show_list(List *list)                    ;    //8.2 逆序输出链表信息</span><br><span class="line">int       get_list_count(List *list)                       ;    //9.  得到链表节点数量</span><br><span class="line">List      *merge_two_lists(List *list1, List *list2)       ;    //10.  合并两个有序链表</span><br><span class="line">List      *merge_two_lists_recure(List *list1, List *list2);    //11.  合并两个有序链表（递归）</span><br><span class="line">List      *reverse_list(List *list)                        ;    //12.  逆置一个链表</span><br><span class="line">List      *list_dump(List *list)                           ;    //13.  链表的拷贝</span><br><span class="line">Boolean   is_list_intersect(List *list1, List *list2)      ;    //14.  判断链表是否有交点</span><br><span class="line">List_node *get_first_common_node(List *list1, List *list2) ;    //15.  得到第一个交点</span><br><span class="line">Boolean   has_circle(List *list)                           ;    //16.  判断一个链表是否有环</span><br><span class="line">List_node *find_circle_first_node(List *list)              ;    //17.  找到带环链表的环入口节点</span><br></pre></td></tr></tbody></table></figure></div>

<p>我们将这些都放入ctl_list.h文件当中，包括链表的定义，链表的接口，一些用到的宏定义。</p>
<p>为了能够方便的进行程序的设计，我们仍旧采用包裹函数的方式对某些操作进行简化：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*接口包裹函数定义*/</span><br><span class="line"></span><br><span class="line">static void *Malloc(size_t size);</span><br><span class="line">static List_node *Create_node(void); </span><br><span class="line">static void Swap(void *a, void *b, int length);</span><br><span class="line">static void Rev_show_list(List_node *node);</span><br></pre></td></tr></tbody></table></figure></div>

<p>我们常用到的操作函数定义如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*接口包裹函数实现*/</span><br><span class="line"></span><br><span class="line">static void *Malloc(size_t size)</span><br><span class="line">{</span><br><span class="line">    void *result = malloc(size);</span><br><span class="line">    if(result == NULL){</span><br><span class="line">        fprintf(stderr, "the memory is full\n");</span><br><span class="line">        exit(1);</span><br><span class="line">    }</span><br><span class="line">    return result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">static List_node *Create_node(void)    //创建链表节点</span><br><span class="line">{</span><br><span class="line">    List_node *node = (List_node *)Malloc(sizeof(List_node));</span><br><span class="line">    bzero(node, sizeof(List_node));</span><br><span class="line"></span><br><span class="line">    return node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">static void Swap(void *a, void *b, int length)</span><br><span class="line">{</span><br><span class="line">    void *temp = Malloc(length);</span><br><span class="line">    memcpy(temp, a, length);</span><br><span class="line">    memcpy(a, b, length);</span><br><span class="line">    memcpy(b, temp, length);</span><br><span class="line">    </span><br><span class="line">    free(temp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">static void Rev_show_list(List_node *node)</span><br><span class="line">{</span><br><span class="line">   //要打印当前节点，先打印其后续节点</span><br><span class="line">   if(node != NULL){</span><br><span class="line">       rev_show_list(node->next);</span><br><span class="line">       printf("%d ", node->data);    </span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>宏定义如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*控制链表宏定义*/</span><br><span class="line"></span><br><span class="line">#define TRUE               (1)</span><br><span class="line">#define FALSE              (0)</span><br><span class="line">#define ZERO               (0)</span><br><span class="line">#define ONLY_ONE           (1)</span><br><span class="line">#define TWO                (2)</span><br><span class="line">#define get_data_size()    ((unsigned long)&(((List_node *)0)->next))</span><br></pre></td></tr></tbody></table></figure></div>

<h3 id="三、链表接口的实现"><a href="#三、链表接口的实现" class="headerlink" title="三、链表接口的实现"></a><strong>三、链表接口的实现</strong></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1.链表的初始化</span><br><span class="line">//      | head | tail | count |</span><br><span class="line">//          \      /      0</span><br><span class="line">//           \    /</span><br><span class="line">//            NULL</span><br><span class="line">List      *init_list(void)                            </span><br><span class="line">{</span><br><span class="line">    List *list = (List *)Malloc(sizeof(List));</span><br><span class="line">    </span><br><span class="line">    bzero(list, sizeof(List));    //全部清零</span><br><span class="line"></span><br><span class="line">    return list; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//2. 链表的销毁</span><br><span class="line">//              list</span><br><span class="line">//             /</span><br><span class="line">//         list_head  </span><br><span class="line">//          /</span><br><span class="line">//      | head | tail | count |</span><br><span class="line">//          \         \   n + 1</span><br><span class="line">//             </span><br><span class="line">//            \          \</span><br><span class="line">//            node->node2->node3</span><br><span class="line"></span><br><span class="line">void      destroy_list(List **list)                   </span><br><span class="line">{</span><br><span class="line">    if(list == NULL || *list == NULL){</span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    //  链表删除步骤：</span><br><span class="line">    //  1.删除链表节点信息;</span><br><span class="line">    while((*list)->count){   //头部删除链表节点</span><br><span class="line">        pop_front(*list);</span><br><span class="line">    }</span><br><span class="line">    //  2.删除链表控制信息.</span><br><span class="line">    free(*list);</span><br><span class="line">    *list = NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//3.1 头部插入</span><br><span class="line">Boolean   push_front(List *list, int value)           </span><br><span class="line">{</span><br><span class="line">    List_node *node = NULL;</span><br><span class="line">  </span><br><span class="line">    if(list == NULL){ </span><br><span class="line">        return FALSE;</span><br><span class="line">    }   </span><br><span class="line"></span><br><span class="line">    //创建节点并赋值</span><br><span class="line">    node = create_node();</span><br><span class="line">    node->data = value;</span><br><span class="line"></span><br><span class="line">    //   case1:</span><br><span class="line">    //      | head | tail | count |</span><br><span class="line">    //          \      /      1</span><br><span class="line">    //           \    /</span><br><span class="line">    //            node</span><br><span class="line">    if(list->count == ZERO){</span><br><span class="line">        list->tail = node;</span><br><span class="line">    }else{</span><br><span class="line">    //   case2:</span><br><span class="line">    //      | head |              tail | count |</span><br><span class="line">    //          \                 /       n + 1</span><br><span class="line">    //           \               /</span><br><span class="line">    //            node->node2->node3</span><br><span class="line">        node->next = list->head;</span><br><span class="line">    }</span><br><span class="line">    list->head = node;</span><br><span class="line">    list->count++;</span><br><span class="line">    return TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//3.2 尾部插入</span><br><span class="line">Boolean   push_back(List  *list, int value)           </span><br><span class="line">{</span><br><span class="line">    List_node *node = NULL;</span><br><span class="line"></span><br><span class="line">    if(list == NULL){</span><br><span class="line">        return FALSE;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    node = create_node();</span><br><span class="line">    node->data = value;</span><br><span class="line"></span><br><span class="line">    //   case1:</span><br><span class="line">    //      | head | tail | count |</span><br><span class="line">    //          \      /      1</span><br><span class="line">    //           \    /</span><br><span class="line">    //            node</span><br><span class="line">    if(list->count == ZERO){</span><br><span class="line">       list->head = list->tail = node;</span><br><span class="line">    }else{</span><br><span class="line">        //   case2:</span><br><span class="line">        //      | head |              tail | count |</span><br><span class="line">        //          \                 /       n + 1</span><br><span class="line">        //           \               /</span><br><span class="line">        //            node1->node2->node</span><br><span class="line">        list->tail->next = node;</span><br><span class="line">        list->tail = node;</span><br><span class="line">    }</span><br><span class="line">    list->count++;</span><br><span class="line">    return TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//4.1 头部删除</span><br><span class="line">Boolean   pop_front(List *list)                       </span><br><span class="line">{</span><br><span class="line">    List_node *p_node = NULL;</span><br><span class="line"></span><br><span class="line">    if(list == NULL || list->count == ZERO){</span><br><span class="line">        return FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //   case1:</span><br><span class="line">    //      | head | tail | count |</span><br><span class="line">    //          \      /      1->0</span><br><span class="line">    //           \    /</span><br><span class="line">    //            node</span><br><span class="line">    </span><br><span class="line">    //   case2:</span><br><span class="line">    //      | head |              tail | count |</span><br><span class="line">    //          \                 /       n-> n - 1</span><br><span class="line">    //           \               /</span><br><span class="line">    //            node1->node2->node3</span><br><span class="line">    p_node = list->head;</span><br><span class="line">    if(list->count == ONLY_ONE){</span><br><span class="line">        list->head = list->tail = NULL; </span><br><span class="line">    }else{</span><br><span class="line">        list->head = list->head->next;</span><br><span class="line">    }</span><br><span class="line">    free(p_node);</span><br><span class="line">    list->count--;</span><br><span class="line">    return TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//4.2 尾部删除</span><br><span class="line">Boolean   pop_back(List *list)                        </span><br><span class="line">{</span><br><span class="line">    List_node *p_node = NULL;</span><br><span class="line"></span><br><span class="line">    if(list == NULL || list->count == ZERO){ </span><br><span class="line">        return FALSE;</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    //   case1:</span><br><span class="line">    //      | head | tail | count |</span><br><span class="line">    //          \      /      1->0</span><br><span class="line">    //           \    /</span><br><span class="line">    //            node</span><br><span class="line">    </span><br><span class="line">    //   case2:</span><br><span class="line">    //      | head |              tail | count |</span><br><span class="line">    //          \                 /       n-> n - 1</span><br><span class="line">    //           \               /</span><br><span class="line">    //            node1->node2->node3</span><br><span class="line">    p_node = list->head; </span><br><span class="line">    if(list->count == ONLY_ONE){    </span><br><span class="line">        list->head = list->tail = NULL;</span><br><span class="line">        free(p_node);</span><br><span class="line">    }else{</span><br><span class="line">        //判断倒数第二个？</span><br><span class="line">        //   p_node->next == list->tail</span><br><span class="line">        while(p_node->next != list->tail){</span><br><span class="line">            p_node = p_node->next;</span><br><span class="line">        }</span><br><span class="line">        free(list->tail);</span><br><span class="line">        list->tail = p_node;</span><br><span class="line">        p_node->next = NULL;</span><br><span class="line">    }</span><br><span class="line">    list->count--;</span><br><span class="line">    return TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//5.1 链表的查找</span><br><span class="line">List_node *find_node(List *list, int value)</span><br><span class="line">{</span><br><span class="line">    if(list == NULL)</span><br><span class="line">    {</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line">    List_node *p = list->head;</span><br><span class="line">    while(p != NULL)</span><br><span class="line">    {</span><br><span class="line">        if(p->data == value)</span><br><span class="line">        {</span><br><span class="line">            printf("found the value: %d\n", value);</span><br><span class="line">            return p;</span><br><span class="line">        }</span><br><span class="line">        p = p->next;</span><br><span class="line">    }</span><br><span class="line">    printf("No found!");</span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//5.2 找到链表的倒数第num个节点</span><br><span class="line">List_node *find_revise_node(List *list, int num)   </span><br><span class="line">{</span><br><span class="line">    List_node *move = NULL;</span><br><span class="line">    int move_count = 0;</span><br><span class="line">    //move + num == count</span><br><span class="line">    if(list == NULL || num <= 0 || num > list->count){</span><br><span class="line">        return NULL;</span><br><span class="line">    }    </span><br><span class="line"></span><br><span class="line">    move = list->head;</span><br><span class="line">    //移动的步长</span><br><span class="line">    move_count = list->count - num;</span><br><span class="line"></span><br><span class="line">    while(move_count--){</span><br><span class="line">        move = move->next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return move;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//5.3 找到链表的中间节点</span><br><span class="line">    // 1.) 快慢指针：</span><br><span class="line">    //</span><br><span class="line">    //       f  每次移动2步， s 每次移动1步</span><br><span class="line">    //       10  23  5  15  50  67  45  32  82</span><br><span class="line">    //</span><br><span class="line">    // 2.)   10 /  2 == 5</span><br><span class="line">    //       10 >> 1 == 5</span><br><span class="line">    //</span><br><span class="line">    //       0000 1010   10</span><br><span class="line">    //            10 >> 1</span><br><span class="line">    //       0000 0101   5</span><br><span class="line">List_node *find_mid_node(List *list)    </span><br><span class="line">{</span><br><span class="line">    List_node *move = NULL;</span><br><span class="line">    int move_count = 0;</span><br><span class="line"></span><br><span class="line">    if(list == NULL){</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    move = list->head;</span><br><span class="line">    move_count = list->count >> 1;</span><br><span class="line"></span><br><span class="line">    while(move_count--){</span><br><span class="line">        move = move->next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return move;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//6.1 链表节点的修改</span><br><span class="line">void modify_node(List *list, int index, int value)</span><br><span class="line">{</span><br><span class="line">    int count = index;</span><br><span class="line">    List_node *p = list->head;</span><br><span class="line">    </span><br><span class="line">    if(list == NULL || index >= list->count || index < 0)</span><br><span class="line">    {</span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">    while(count--)</span><br><span class="line">    {</span><br><span class="line">        p = p->next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    p->data = value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//6.2链表节点的插入</span><br><span class="line">Boolean insert_node(List *list,int index, int value)</span><br><span class="line">{</span><br><span class="line">    if(list == NULL || index > list->count || index < 0)</span><br><span class="line">    {</span><br><span class="line">        return FALSE;</span><br><span class="line">    }</span><br><span class="line">    //在最后则尾部插入</span><br><span class="line">    if(index == list->count)</span><br><span class="line">    {</span><br><span class="line">        return push_back(list, value);</span><br><span class="line">    }</span><br><span class="line">    //在最前则头部插入</span><br><span class="line">    if(index == 0)</span><br><span class="line">    {</span><br><span class="line">        return push_front(list, value);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    int count =  index -1;</span><br><span class="line">    List_node *p_node = list->head;</span><br><span class="line"></span><br><span class="line">    //创建新节点</span><br><span class="line">    List_node *node = create_node();</span><br><span class="line">    node->data = value;</span><br><span class="line">    </span><br><span class="line">	//寻找需插入的节点位置</span><br><span class="line">    while(count--)</span><br><span class="line">    {</span><br><span class="line">        p_node = p_node->next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	//进行插入</span><br><span class="line">    node->next = p_node->next;</span><br><span class="line">    p_node->next = node;</span><br><span class="line"></span><br><span class="line">    list->count++;</span><br><span class="line">    return TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//6.3 在O（1）的时间复杂度删除节点</span><br><span class="line">	//由于是单链表，无法获取到前一个节点的位置，</span><br><span class="line">	//所以，我们在这里用后一个节点代替我们所需的节点。</span><br><span class="line">void      delete_one_node(List *list, List_node *node)   </span><br><span class="line">{</span><br><span class="line">	if(list == NULL || node == NULL)</span><br><span class="line">	{</span><br><span class="line">	    return ;</span><br><span class="line">	}</span><br><span class="line">	//尾部删除</span><br><span class="line">    if(node == list->tail)</span><br><span class="line">    {</span><br><span class="line">        pop_back(list);</span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line">    List_node *p = node->next;//保存下一个节点位置</span><br><span class="line"></span><br><span class="line">    node->data = node->next->data; //这个节点作为后一个的替代</span><br><span class="line">    node->next = node->next->next; //直接指向下一个节点的后面</span><br><span class="line">    free(p);</span><br><span class="line">    list->count--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//7.1 升序排列</span><br><span class="line"> //我们在这里用到了一种新的办法求我们的结构体大小，定义在宏里：</span><br><span class="line"> </span><br><span class="line"> // ((unsigned long)&(((List_node *)0)->next))</span><br><span class="line"> //    </span><br><span class="line"> //                    (List_node *)0          //指向首地址在0的List_node的指针</span><br><span class="line"> //                   ((List_node *)0)->next)  //取next则指向了它的下一个</span><br><span class="line"> //                 &(((List_node *)0)->next)) //取地址，得到的是这个地址，由于首地址，则正好是大小</span><br><span class="line"> // ((unsigned long)&(((List_node *)0)->next)) //unsigned long 类型转换，得到就是大小</span><br><span class="line"> // sizeof(List_node) - sizeof(List_node *);</span><br><span class="line"> </span><br><span class="line">   //内存分配，结构体里内存对齐现象：</span><br><span class="line">    // int               data;  // 0   1   2   3</span><br><span class="line">    //                          // 4   5   6   7</span><br><span class="line">    // struct List_Node *next;  // 8   9  10  11</span><br><span class="line">    //                            12  13  14  15</span><br><span class="line">    </span><br><span class="line">void      sort_list_ascend(List *list)                </span><br><span class="line">{</span><br><span class="line">    List_node *p_node = NULL;</span><br><span class="line">    List_node *q_node = NULL;</span><br><span class="line">    unsigned long data_size = 0;</span><br><span class="line"></span><br><span class="line">    if(list == NULL || list->count < TWO){</span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    data_size = get_data_size();    //求得数据区域得大小</span><br><span class="line">    for(p_node = list->head; p_node->next; p_node = p_node->next){</span><br><span class="line">        for(q_node = p_node->next; q_node ; q_node = q_node->next){</span><br><span class="line">            if(p_node->data > q_node->data){ </span><br><span class="line">                swap(p_node, q_node, data_size);                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//7.2 降序排列</span><br><span class="line">  //和升序类似</span><br><span class="line">void      sort_list_descend(List *list)               </span><br><span class="line">{</span><br><span class="line">    List_node *p_node = NULL;</span><br><span class="line">    List_node *q_node = NULL;</span><br><span class="line">    unsigned long data_size = 0;</span><br><span class="line"></span><br><span class="line">    if(list == NULL || list->count < TWO){</span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data_size = get_data_size();    //求得数据区域得大小</span><br><span class="line">    for(p_node = list->head; p_node->next; p_node = p_node->next){</span><br><span class="line">        for(q_node = p_node->next; q_node ; q_node = q_node->next){</span><br><span class="line">            if(p_node->data < q_node->data){ </span><br><span class="line">                swap(p_node, q_node, data_size);                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//8.1 显示链表信息</span><br><span class="line">void      show_list(List *list)                       </span><br><span class="line">{</span><br><span class="line">    List_node *p_node = NULL;</span><br><span class="line"></span><br><span class="line">    if(list != NULL && list->count != ZERO){ </span><br><span class="line">        for(p_node = list->head; p_node; p_node = p_node->next){ </span><br><span class="line">            printf("%d ", p_node->data);</span><br><span class="line">        }</span><br><span class="line">        printf("\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//8.2 逆序输出链表信息</span><br><span class="line">void      reverse_show_list(List *list)    </span><br><span class="line">{</span><br><span class="line">    if(list == NULL || list->count == ZERO){</span><br><span class="line">        return ;</span><br><span class="line">    }  </span><br><span class="line">    // .h中定义的递归（先递归再输出）</span><br><span class="line">    Rev_show_list(list->head);</span><br><span class="line">    printf("\n");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//9 得到链表节点数量</span><br><span class="line">  //这是一个有控制信息的链表，有关于节点数量的变量</span><br><span class="line">int       get_list_count(List *list)                  </span><br><span class="line">{</span><br><span class="line">    if(list == NULL){ </span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line">    return list->count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">///10 合并两个有序链表</span><br><span class="line">    //l1    | head |              tail | count |</span><br><span class="line">    //          \                 /       n-> n - 1</span><br><span class="line">    //           \               /</span><br><span class="line">    //            node1->node2->node3</span><br><span class="line">    //</span><br><span class="line">    //</span><br><span class="line">    //l2    | head |              tail | count |</span><br><span class="line">    //          \                 /       n-> n - 1</span><br><span class="line">    //           \               /</span><br><span class="line">    //            node1->node2->node3</span><br><span class="line">    //</span><br><span class="line">List      *merge_two_lists(List *list1, List *list2)    </span><br><span class="line">{</span><br><span class="line">    List *result = NULL;</span><br><span class="line">    List_node *list1_move = NULL;   </span><br><span class="line">    List_node *list2_move = NULL;   </span><br><span class="line"></span><br><span class="line">    if(list1 == NULL || list2 == NULL){</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    result = init_list();   //结果链表得初始化</span><br><span class="line"></span><br><span class="line">    list1_move = list1->head;</span><br><span class="line">    list2_move = list2->head;</span><br><span class="line"></span><br><span class="line">    //如果两个链表都没有遍历完，进行比较</span><br><span class="line">    while(list1_move != NULL && list2_move != NULL){</span><br><span class="line">        if(list1_move->data <= list2_move->data){</span><br><span class="line">            push_back(result, list1_move->data);</span><br><span class="line">            list1_move = list1_move->next;</span><br><span class="line">        }else{</span><br><span class="line">            push_back(result, list2_move->data);</span><br><span class="line">            list2_move = list2_move->next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //当两个链表中任何一个遍历结束，则把另外一个进行尾部添加</span><br><span class="line">    while(list2_move != NULL){</span><br><span class="line">        push_back(result, list2_move->data);</span><br><span class="line">        list2_move = list2_move->next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    while(list1_move != NULL){</span><br><span class="line">        push_back(result, list1_move->data);</span><br><span class="line">        list1_move = list1_move->next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//11//合并两个有序链表（递归）</span><br><span class="line">    //   </span><br><span class="line">    //l1            node1->node2->node3</span><br><span class="line">    //</span><br><span class="line">    //     l->node1->node4...</span><br><span class="line">    //    </span><br><span class="line">    //l2            node4->node5->node6</span><br><span class="line">    //</span><br><span class="line">List      *merge_two_lists_recure(List *list1, List *list2)    </span><br><span class="line">{</span><br><span class="line">    List *node = NULL;</span><br><span class="line">    List *l  = init_list();</span><br><span class="line">    List *l1 = list1;</span><br><span class="line">    List *l2 = list2;</span><br><span class="line"></span><br><span class="line">    if(l1->count == 0)</span><br><span class="line">    {</span><br><span class="line">        return list2;</span><br><span class="line">    }</span><br><span class="line">    if(l2->count == 0)</span><br><span class="line">    {</span><br><span class="line">        return list1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //若l1当前head满足较小情况，将l指向l1,让l1指向l1的下一个节点，进入递归比较l1->head->next形成的链表与l2再进行比较，返回的node链表是后面节点的新链表;</span><br><span class="line">    if(l1->head->data < l2->head->data)</span><br><span class="line">    {</span><br><span class="line">        l->head = l1->head;</span><br><span class="line">        l1->head = l1->head->next;</span><br><span class="line">        l1->count --;</span><br><span class="line">        node = merge_two_lists_recure(l1, l2);</span><br><span class="line">    }</span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        l->head = l2->head;</span><br><span class="line">        l2->head = l2->head->next;</span><br><span class="line">        l2->count--;</span><br><span class="line">        node = merge_two_lists_recure(l1, l2);</span><br><span class="line">    }</span><br><span class="line">    //完成递归后，l指向node组成的新链表;</span><br><span class="line">    l->head->next = node->head;</span><br><span class="line">    l->count = node->count +1;</span><br><span class="line">    return l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//12 逆置一个链表</span><br><span class="line">    //因为会改变结构，为了不失去对后面的节点的信息，使用了三个指针，交换前两个，不丢失第三个 。</span><br><span class="line">    //</span><br><span class="line">    //      | head |              tail | count |</span><br><span class="line">    //          \                   \      n-> n - 1</span><br><span class="line">    //           \                   \</span><br><span class="line">    //            node1->node2->node3->node4</span><br><span class="line">    //             |      |       |</span><br><span class="line">    //             p      q       m</span><br><span class="line">    //</span><br><span class="line">    //            node1<-node2 node3->node4</span><br><span class="line">    //             |      |       |      |</span><br><span class="line">    //             p      q       m      |</span><br><span class="line">    //                    p       q      m   </span><br><span class="line">    //</span><br><span class="line">    </span><br><span class="line">List      *reverse_list(List *list)    </span><br><span class="line">{</span><br><span class="line">    List_node *p_node = NULL;</span><br><span class="line">    List_node *q_node = NULL;</span><br><span class="line">    List_node *m_node = NULL;</span><br><span class="line"></span><br><span class="line">    if(list == NULL || list->count < TWO){</span><br><span class="line">        return list;</span><br><span class="line">    } </span><br><span class="line">    //两个节点</span><br><span class="line">    if(list->count == TWO){</span><br><span class="line">        list->tail->next = list->head;</span><br><span class="line">        list->head->next = NULL;</span><br><span class="line">    }else{    //三个节点</span><br><span class="line">        p_node = list->head;</span><br><span class="line">        q_node = p_node->next;</span><br><span class="line">        m_node = q_node->next;</span><br><span class="line">        p_node->next = NULL;</span><br><span class="line">        do{</span><br><span class="line">            q_node->next = p_node;   //让中间指针的next指向前一个</span><br><span class="line">            p_node = q_node;    //指针整体向后搬移</span><br><span class="line">            q_node = m_node;</span><br><span class="line">            m_node = m_node->next;</span><br><span class="line">        }while(m_node != NULL);</span><br><span class="line">        q_node->next = p_node;</span><br><span class="line">    }</span><br><span class="line">    //交换头尾指针</span><br><span class="line">    swap(&(list->head), &(list->tail), sizeof(List_node *));</span><br><span class="line">    return list;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//13 链表的拷贝</span><br><span class="line">  //使用了尾插法依次将元素插入</span><br><span class="line">List      *list_dump(List *list)    </span><br><span class="line">{</span><br><span class="line">    List * new_list = init_list();</span><br><span class="line">    List_node * node = list->head;</span><br><span class="line">    for(node = list->head; node; node = node->next)</span><br><span class="line">    {</span><br><span class="line">        push_back(new_list, node->data);</span><br><span class="line">    }</span><br><span class="line">    return new_list;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//14 判断链表是否有交点</span><br><span class="line">  //若两个链表有交点，则尾节点一定是同一个。</span><br><span class="line">  //</span><br><span class="line">  //  l1-> => => =></span><br><span class="line">  //                \</span><br><span class="line">  //                 \     </span><br><span class="line">  //                 /  => => => => => =></span><br><span class="line">  //  l2-> => => => </span><br><span class="line">  //</span><br><span class="line">Boolean   is_list_intersect(List *list1, List *list2)    </span><br><span class="line">{</span><br><span class="line">    if(list1 == NULL || list2 == NULL){</span><br><span class="line">        return FALSE;</span><br><span class="line">    }</span><br><span class="line">//    </span><br><span class="line">    if( list1->tail == list2->tail)</span><br><span class="line">    {</span><br><span class="line">        printf("intersect\n");</span><br><span class="line">        return TRUE;</span><br><span class="line">    }</span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        printf("nothing\n");</span><br><span class="line">        return FALSE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//15 得到第一个交点</span><br><span class="line">  //             l1 =></span><br><span class="line">  //                    \     </span><br><span class="line">  //                    /   => => => => => =></span><br><span class="line">  //     l2 => => => => </span><br><span class="line">  //     长度不等，先获得两个链表都离相遇点长度相等的地方开始依次比较。</span><br><span class="line">List_node *get_first_common_node(List *list1, List *list2)    </span><br><span class="line">{</span><br><span class="line">    int list1_len = 0;</span><br><span class="line">    int list2_len = 0;</span><br><span class="line">    int distance = 0;</span><br><span class="line">    List_node *p_node = NULL;</span><br><span class="line">    List_node *q_node = NULL;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if(!is_list_intersect(list1, list2)){    //判断两个链表是否有交点</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    list1_len = list1->count;</span><br><span class="line">    list2_len = list2->count;</span><br><span class="line"></span><br><span class="line">    p_node = list1->head;</span><br><span class="line">    q_node = list2->head;</span><br><span class="line"></span><br><span class="line">    //判断较长链表并首先进行移动</span><br><span class="line">    if(list1_len >= list2_len){</span><br><span class="line">        distance = list1_len - list2_len;</span><br><span class="line">        while(distance--){ </span><br><span class="line">            p_node = p_node->next;</span><br><span class="line">        }</span><br><span class="line">    }else{</span><br><span class="line">        distance = list2_len - list1_len;</span><br><span class="line">        while(distance--){</span><br><span class="line">            q_node = q_node->next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //依次对对应节点进行判断是否相等，如果相等则是第一个相交节点</span><br><span class="line">    while(p_node != q_node){</span><br><span class="line">        p_node = p_node->next;</span><br><span class="line">        q_node = q_node->next;</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    return p_node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//16 判断一个链表是否有环</span><br><span class="line">  //</span><br><span class="line">  //   - - - 、  </span><br><span class="line">  //          \    - - - - 、</span><br><span class="line">  //           \ /          |</span><br><span class="line">  //            \          /</span><br><span class="line">  //             ` - - - -</span><br><span class="line">  //</span><br><span class="line">Boolean has_circle(List *list)                                </span><br><span class="line">{</span><br><span class="line">    List_node *p = list->head;  //slow</span><br><span class="line">    List_node *q = list->head;  //fast</span><br><span class="line">    while(p != NULL && q != NULL && q->next !=NULL)</span><br><span class="line">    {</span><br><span class="line">        p = p->next;        //一次一步</span><br><span class="line">        q = q->next->next;  //一次两步</span><br><span class="line"></span><br><span class="line">        //如果有环，则一定会相遇</span><br><span class="line">        if(p == q)</span><br><span class="line">        {</span><br><span class="line">            printf("we found circle!\n");</span><br><span class="line">            return TRUE;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    printf("no circle!\n");</span><br><span class="line">    return FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//17 找到带环链表的环入口节点</span><br><span class="line">  //</span><br><span class="line">  //   - - - 、  </span><br><span class="line">  //          \    - - - - 、</span><br><span class="line">  //           \ /          |</span><br><span class="line">  //            \          /</span><br><span class="line">  //        入口点 ` - -*- -</span><br><span class="line">  //                   \</span><br><span class="line">  //                     相遇点</span><br><span class="line">  //            |<-x->|</span><br><span class="line">  //  |<---a--->|<-----r---->|</span><br><span class="line">  //  |<----------L--------->|</span><br><span class="line">  // 我们设整个链表长L，入口点与相遇点长x，起点到入口点长度为a;</span><br><span class="line">  // 快指针走的长度是慢指针的2倍，由于快指针可能不止走了一圈;</span><br><span class="line">  // 慢指针走了s步，即快指针走了2s步。</span><br><span class="line">  //</span><br><span class="line">  // ∵ 2s = s + nr ;</span><br><span class="line">  // ∴ s = nr;</span><br><span class="line">  //</span><br><span class="line">  //   a + x = nr</span><br><span class="line">  //   a + x = nr = (n-1)r + r =  (n-1)r + L -a</span><br><span class="line">  //   a = (n-1)r + (L -a -x)</span><br><span class="line">  //   链表从头到环入口点长度 = (n -1)环长 + 相遇点到环入口长度</span><br><span class="line">  //   所以， 从链表头和相遇点各设一个一步长的指针，必定会在相遇点回合。</span><br><span class="line">  //</span><br><span class="line">List_node *find_circle_first_node(List *list)                  </span><br><span class="line">{</span><br><span class="line">    List_node * entry = NULL;</span><br><span class="line">    if(!has_circle(list))</span><br><span class="line">    {</span><br><span class="line">        return NULL;</span><br><span class="line">    }</span><br><span class="line">    List_node *p = list->head;  //slow</span><br><span class="line">    List_node *q = list->head;  //fast</span><br><span class="line">    while(p != NULL && q != NULL && q->next !=NULL)</span><br><span class="line">    {</span><br><span class="line">        p = p->next;</span><br><span class="line">        q = q->next->next;</span><br><span class="line">        if(p == q)</span><br><span class="line">        {</span><br><span class="line">            break;    //相遇点p和q</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    //p为相遇点开始</span><br><span class="line">    q = list->head;   //q从链表头开始</span><br><span class="line">    while(q != p)</span><br><span class="line">    {</span><br><span class="line">        p =p->next;</span><br><span class="line">        q =q->next;</span><br><span class="line">    }</span><br><span class="line">    printf("we found the node is %d\n", q->data);</span><br><span class="line">    return q;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h3 id="四、测试功能"><a href="#四、测试功能" class="headerlink" title="四、测试功能"></a><strong>四、测试功能</strong></h3><p>测试代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">#include "list.h"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int i = 0;</span><br><span class="line">    int num = 0;</span><br><span class="line">    List *list = NULL;</span><br><span class="line">    List *list1 = NULL;</span><br><span class="line">    List *list2 = NULL;</span><br><span class="line">    List_node * node = NULL;</span><br><span class="line">    </span><br><span class="line">    printf("1.init_list:\n");</span><br><span class="line">    list = init_list();</span><br><span class="line">    list1 = init_list();</span><br><span class="line">    list2 = init_list();</span><br><span class="line">    </span><br><span class="line">    printf("3.1 list1 push_front :\n");</span><br><span class="line">    for(i = 0; i < 6; i++)</span><br><span class="line">    {</span><br><span class="line">        push_front(list1, rand()%100);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    show_list(list1);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    printf("3.2 list2 push_back:\n");</span><br><span class="line">    for(i = 0; i < 4; i++)</span><br><span class="line">    {</span><br><span class="line">        push_back(list2, rand()%100);</span><br><span class="line">    }</span><br><span class="line">    show_list(list2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf("4.1 list1 pop_front:\n");</span><br><span class="line">    pop_front(list1);</span><br><span class="line">    show_list(list1);</span><br><span class="line"></span><br><span class="line">    printf("4.2 list2 pop_back:\n");</span><br><span class="line">    pop_back(list2);</span><br><span class="line">    show_list(list2);</span><br><span class="line">    </span><br><span class="line">    printf("7.1 sort_list1_ascend:\n");                   </span><br><span class="line">    sort_list_ascend(list1);                  </span><br><span class="line">    show_list(list1);</span><br><span class="line">    </span><br><span class="line">    printf("7.2 sort_list2_descend:\n");                   </span><br><span class="line">    sort_list_descend(list2);                  </span><br><span class="line">    show_list(list2);</span><br><span class="line"></span><br><span class="line">    printf("12 reverse_list2:\n");</span><br><span class="line">    reverse_list(list2);</span><br><span class="line">    show_list(list2);</span><br><span class="line">    </span><br><span class="line">#if 0</span><br><span class="line">    printf("10. list : merge_two_lists(list1, list2):\n");</span><br><span class="line">    list = merge_two_lists(list1, list2);</span><br><span class="line">    show_list(list);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">    printf("11. list : merge_two_lists_recure(list1, list2):\n");</span><br><span class="line">    list = merge_two_lists_recure(list1, list2);</span><br><span class="line">    show_list(list);</span><br><span class="line">#endif</span><br><span class="line">         </span><br><span class="line">    printf("8.1 show_list(list);\n");      </span><br><span class="line">    show_list(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf("8.2 reverse_show_list(list);\n");</span><br><span class="line">    reverse_show_list(list);</span><br><span class="line">#if 1 </span><br><span class="line">    printf("find_node:\n");</span><br><span class="line">    printf("which one?(value to find)\n"); </span><br><span class="line">    scanf("%d",&num);</span><br><span class="line">    printf("found num of list is :%d \n",find_node(list, num)->data);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">    printf("find_revise_node:\n");     </span><br><span class="line">    printf("which one index ?(reverse)\n"); </span><br><span class="line">    scanf("%d",&num);</span><br><span class="line">    printf("reverse num of list is :%d \n",find_revise_node(list, num)->data);</span><br><span class="line">#endif</span><br><span class="line">    printf("5.3 find_mid_node(list):\n") ;</span><br><span class="line">    printf("%d \n",find_mid_node(list)->data);</span><br><span class="line"></span><br><span class="line">    printf("9. get_list_count:\n"); </span><br><span class="line">    printf("the count of list is :%d\n", get_list_count(list));</span><br><span class="line"></span><br><span class="line">#if 1  </span><br><span class="line">    printf("6.3 delete_one_node:");</span><br><span class="line">    printf("which one?(to delete)\n"); </span><br><span class="line">    scanf("%d",&num);</span><br><span class="line">    node = create_node();</span><br><span class="line">    node = find_node(list,num);</span><br><span class="line">    delete_one_node(list, node);</span><br><span class="line">    show_list(list);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">    printf("6.1 modify_node :\n");</span><br><span class="line">    modify_node(list, 1, 26);</span><br><span class="line">    show_list(list);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">    printf("6.2 insert_node: \n");</span><br><span class="line">    insert_node(list, 2, 18);</span><br><span class="line">    show_list(list);</span><br><span class="line">#endif </span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">    printf("16. has_circle:\n");</span><br><span class="line">    //list->head->next->next->next->next->next = list->head->next;</span><br><span class="line"></span><br><span class="line">    if(has_circle(list))</span><br><span class="line">    {</span><br><span class="line">        printf("17 find_circle_first_node:\n");</span><br><span class="line">        find_circle_first_node(list);</span><br><span class="line">    }</span><br><span class="line">#endif</span><br><span class="line">    printf("13. list1:list_dump(list)\n");</span><br><span class="line">    list1 = list_dump(list);</span><br><span class="line">    printf("list1: ");</span><br><span class="line">    show_list(list1);</span><br><span class="line">    </span><br><span class="line">    printf("14. is_list_intersect:\n");</span><br><span class="line">    </span><br><span class="line">    if(is_list_intersect(list1, list))</span><br><span class="line">    {</span><br><span class="line">        printf("the common node: %d\n",get_first_common_node(list1, list));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    printf("2. destroy_list:\n");</span><br><span class="line">    destroy_list(&list1);</span><br><span class="line">    destroy_list(&list2);</span><br><span class="line">    destroy_list(&list);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>运行结果：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">root@aemonair:/ctl_list# ./bin/list </span><br><span class="line">1.init_list:</span><br><span class="line">3.1 list1 push_front :</span><br><span class="line">35 93 15 77 86 83 </span><br><span class="line">3.2 list2 push_back:</span><br><span class="line">86 92 49 21 </span><br><span class="line">4.1 list1 pop_front:</span><br><span class="line">93 15 77 86 83 </span><br><span class="line">4.2 list2 pop_back:</span><br><span class="line">86 92 49 </span><br><span class="line">7.1 sort_list1_ascend:</span><br><span class="line">15 77 83 86 93 </span><br><span class="line">7.2 sort_list2_descend:</span><br><span class="line">92 86 49 </span><br><span class="line">12 reverse_list2:</span><br><span class="line">49 86 92 </span><br><span class="line">11. list : merge_two_lists_recure(list1, list2):</span><br><span class="line">15 49 77 83 86 86 92 93 </span><br><span class="line">8.1 show_list(list);</span><br><span class="line">15 49 77 83 86 86 92 93 </span><br><span class="line">8.2 reverse_show_list(list);</span><br><span class="line">93 92 86 86 83 77 49 15 </span><br><span class="line">find_node:</span><br><span class="line">which one?(value to find)</span><br><span class="line">92</span><br><span class="line">found the value: 92</span><br><span class="line">found num of list is :92 </span><br><span class="line">find_revise_node:</span><br><span class="line">which one index ?(reverse)</span><br><span class="line">2</span><br><span class="line">reverse num of list is :92 </span><br><span class="line">5.3 find_mid_node(list):</span><br><span class="line">86 </span><br><span class="line">9. get_list_count:</span><br><span class="line">the count of list is :8</span><br><span class="line">6.3 delete_one_node:which one?(to delete)</span><br><span class="line">92</span><br><span class="line">found the value: 92</span><br><span class="line">15 49 77 83 86 86 93 </span><br><span class="line">6.1 modify_node :</span><br><span class="line">15 26 77 83 86 86 93 </span><br><span class="line">6.2 insert_node: </span><br><span class="line">15 26 18 77 83 86 86 93 </span><br><span class="line">16. has_circle:</span><br><span class="line">no circle!</span><br><span class="line">13. list1:list_dump(list)</span><br><span class="line">list1: 15 26 18 77 83 86 86 93 </span><br><span class="line">14. is_list_intersect:</span><br><span class="line">nothing</span><br><span class="line">2. destroy_list:</span><br></pre></td></tr></tbody></table></figure></div>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>至此。我们完成了对<em>带控制信息链表</em>的定义，实现，测试;<br>我们会发现加上控制信息之后，一些操作被封装起来，有可能更加便捷。<br>这是一种思路，一种方法。<br>以上解法也不一定是最简便快捷的，只是其中一种实现而已。<br>我们还将继续对数据结构进行进一步的探讨。</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:v.aemonair@gmail.com">Air</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aemonair.github.io/2016/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E5%B8%A6%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E9%93%BE%E8%A1%A8/">http://aemonair.github.io/2016/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842-%E5%B8%A6%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E9%93%BE%E8%A1%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Aemonair.github.io">Aemonair</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStruct/">DataStruct    </a><a class="post-meta__tags" href="/tags/LinkedList/">LinkedList    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2016/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843-%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>数据结构3.双端链表</span></div></a></div><div class="next-post pull_right"><a href="/2016/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841_%E5%8D%95%E9%93%BE%E8%A1%A8/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>数据结构1.单链表</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2016/05/31/数据结构1_单链表/" title="数据结构1.单链表"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-31</div><div class="relatedPosts_title">数据结构1.单链表</div></div></a></div><div class="relatedPosts_item"><a href="/2016/06/03/数据结构3-双端链表/" title="数据结构3.双端链表"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-06-03</div><div class="relatedPosts_title">数据结构3.双端链表</div></div></a></div><div class="relatedPosts_item"><a href="/2016/06/17/数据结构5-通用栈/" title="数据结构5.通用栈"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-06-17</div><div class="relatedPosts_title">数据结构5.通用栈</div></div></a></div><div class="relatedPosts_item"><a href="/2016/06/18/数据结构6-通用队列/" title="数据结构6.通用队列"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-06-18</div><div class="relatedPosts_title">数据结构6.通用队列</div></div></a></div><div class="relatedPosts_item"><a href="/2016/06/16/数据结构4-进一步封装的双向链表/" title="数据结构4.进一步封装的双向链表"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-06-16</div><div class="relatedPosts_title">数据结构4.进一步封装的双向链表</div></div></a></div><div class="relatedPosts_item"><a href="/2016/07/24/Sort_2_QuickSort/" title="排序_2.快速排序"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/aemonair/ImageHosting//imges/20200306134808_defalut_bg1.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-07-24</div><div class="relatedPosts_title">排序_2.快速排序</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Air</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">4th ~</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script></body></html>